<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hongwei&#39;s Diary</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiaohongwei.github.io/"/>
  <updated>2019-02-17T06:14:11.641Z</updated>
  <id>https://jiaohongwei.github.io/</id>
  
  <author>
    <name>伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://jiaohongwei.github.io/2019/01/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://jiaohongwei.github.io/2019/01/10/冒泡排序/</id>
    <published>2019-01-10T06:10:28.000Z</published>
    <updated>2019-02-17T06:14:11.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍了手写冒泡排序的基础版和增强版代码（有道云笔记迁移）</p></blockquote><h1 id="一、基础版"><a href="#一、基础版" class="headerlink" title="一、基础版"></a>一、基础版</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基础版</span><br><span class="line"> */</span><br><span class="line">private static void bubbleSort(int[] arr) &#123;</span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                int tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第&quot; + i + &quot;步：&quot; + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、增强版"><a href="#二、增强版" class="headerlink" title="二、增强版"></a>二、增强版</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 增强版</span><br><span class="line"> */</span><br><span class="line">private static void bubbleSortPlus(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 设定一个标记，若为true，则表示此次循环没有进行交换，</span><br><span class="line">             也就是待排序已经有序，排序已经完成</span><br><span class="line">         */</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                int tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = tmp;</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第&quot; + i + &quot;步：&quot; + Arrays.toString(arr));</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍了手写冒泡排序的基础版和增强版代码（有道云笔记迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、基础版&quot;&gt;&lt;a href=&quot;#一、基础版&quot; class=&quot;headerlink&quot; title=&quot;一、基础版&quot;&gt;&lt;/a&gt;一、基础版&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://jiaohongwei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>双重锁单例模式笔记</title>
    <link href="https://jiaohongwei.github.io/2019/01/10/%E5%8F%8C%E9%87%8D%E9%94%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiaohongwei.github.io/2019/01/10/双重锁单例模式笔记/</id>
    <published>2019-01-10T05:53:43.000Z</published>
    <updated>2019-02-17T06:09:21.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍了双重锁的单例模式实现方式和部分问题解答（有道云笔记迁移）</p></blockquote><h1 id="一、代码实现"><a href="#一、代码实现" class="headerlink" title="一、代码实现"></a>一、代码实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Description 双重锁单例模式</span><br><span class="line"> * @Author hw</span><br><span class="line"> * @Date 2019/1/10 16:27</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class SingleTon &#123;</span><br><span class="line">     private static volatile SingleTon singleTon;</span><br><span class="line">     private SingleTon() &#123;&#125;</span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">        if (singleTon == null) &#123;</span><br><span class="line">            synchronized (SingleTon.class) &#123;</span><br><span class="line">                if (singleTon == null) &#123;</span><br><span class="line">                    singleTon = new SingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译后的字节码指令</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10: monitorenter</span><br><span class="line">11: getstatic     #2                  // Field singleTon:LSingleTon;</span><br><span class="line">14: ifnonnull     27</span><br><span class="line">17: new           #3                  // class SingleTon</span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic     #2                  // Field singleTon:LSingleTon;</span><br><span class="line">27: aload_0</span><br><span class="line">28: monitorexit</span><br></pre></td></tr></table></figure><h1 id="二、为什么需要volatile？"><a href="#二、为什么需要volatile？" class="headerlink" title="二、为什么需要volatile？"></a>二、为什么需要volatile？</h1><h2 id="1-禁止指令重排序（有序性）"><a href="#1-禁止指令重排序（有序性）" class="headerlink" title="1. 禁止指令重排序（有序性）"></a>1. 禁止指令重排序（有序性）</h2><blockquote><p>实例化一个对象其实可以分为三个步骤：　　</p></blockquote><ol><li>分配内存空间。　　</li><li>初始化对象。　　</li><li>将内存空间的地址赋值给对应的引用。</li></ol><blockquote><p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：　　</p><ol><li>分配内存空间。　　</li><li>将内存空间的地址赋值给对应的引用。　　</li><li>初始化对象</li></ol></blockquote><h2 id="2-保证singleTon对象的可见性"><a href="#2-保证singleTon对象的可见性" class="headerlink" title="2. 保证singleTon对象的可见性"></a>2. 保证singleTon对象的可见性</h2><h1 id="三、如果synchronized里面不加if判断会发生什么？"><a href="#三、如果synchronized里面不加if判断会发生什么？" class="headerlink" title="三、如果synchronized里面不加if判断会发生什么？"></a>三、如果synchronized里面不加if判断会发生什么？</h1><blockquote><p>多个线程竞争synchronize锁，只有一个拿到，剩下的会在锁释放的时候再次进行new 操作，就会导致执行多次，出现多个实例。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍了双重锁的单例模式实现方式和部分问题解答（有道云笔记迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、代码实现&quot;&gt;&lt;a href=&quot;#一、代码实现&quot; class=&quot;headerlink&quot; title=&quot;一、代码实现&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://jiaohongwei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Base64编码原理</title>
    <link href="https://jiaohongwei.github.io/2018/12/11/Base64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/"/>
    <id>https://jiaohongwei.github.io/2018/12/11/Base64编码原理/</id>
    <published>2018-12-11T04:07:45.000Z</published>
    <updated>2019-02-17T04:25:45.463Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述Base64的编码原理（博客园文章迁移）</p></blockquote><ul><li>Base64是编码方式不是加密方式</li><li>标准的ASCII码 128个中96个可见字符，其余为不可见字符，为了避免不可见字符</li><li>使用了64个可见字符进行编码</li></ul><h1 id="一、原理步骤"><a href="#一、原理步骤" class="headerlink" title="一、原理步骤"></a>一、原理步骤</h1><p>例如：Hello</p><h2 id="1-先转成二进制"><a href="#1-先转成二进制" class="headerlink" title="1. 先转成二进制"></a>1. 先转成二进制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111 00000000</span><br></pre></td></tr></table></figure><h2 id="2-打乱重编码，以6个一组进行重编码，不满足的需要补0"><a href="#2-打乱重编码，以6个一组进行重编码，不满足的需要补0" class="headerlink" title="2. 打乱重编码，以6个一组进行重编码，不满足的需要补0"></a>2. 打乱重编码，以6个一组进行重编码，不满足的需要补0</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010010 000110 010101 101100 011011 000110 111100 000000</span><br></pre></td></tr></table></figure><ul><li>注意：为什么要6个一组，因为一共64个可见字符， 000000 转成十进制是0 ，111111 转成十进制是63，正好64个编号和64个可见字符一一对应。</li><li>24 是8 和6 的最小公倍数，所以要筹够24</li></ul><h2 id="3-然后6个一组转为十进制"><a href="#3-然后6个一组转为十进制" class="headerlink" title="3. 然后6个一组转为十进制"></a>3. 然后6个一组转为十进制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18 6 21 44 27 6 60 0</span><br></pre></td></tr></table></figure><ul><li>补出来的0 结尾都要变成=号</li></ul><h2 id="4-去Base64-对照表拿出相应的字符"><a href="#4-去Base64-对照表拿出相应的字符" class="headerlink" title="4. 去Base64 对照表拿出相应的字符"></a>4. 去Base64 对照表拿出相应的字符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SGVsbG8=</span><br></pre></td></tr></table></figure><h1 id="二、图解"><a href="#二、图解" class="headerlink" title="二、图解"></a>二、图解</h1><p><img src="/2018/12/11/Base64编码原理/20181211003958788.png" alt></p><h1 id="三、Base64索引表"><a href="#三、Base64索引表" class="headerlink" title="三、Base64索引表"></a>三、Base64索引表</h1><p><img src="/2018/12/11/Base64编码原理/20181211004306149.png" alt></p><h1 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h1><p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：</p><ul><li>先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。也就是说，当最后剩余两个八位字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；</li><li>如果最后剩余一个八位字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述Base64的编码原理（博客园文章迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Base64是编码方式不是加密方式&lt;/li&gt;
&lt;li&gt;标准的ASCII码 128个中96个可见字符，其余为不可见字符，为了避免不可见字符&lt;/li
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>开放API接口安全处理</title>
    <link href="https://jiaohongwei.github.io/2018/12/10/%E5%BC%80%E6%94%BEAPI%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86/"/>
    <id>https://jiaohongwei.github.io/2018/12/10/开放API接口安全处理/</id>
    <published>2018-12-10T04:15:00.000Z</published>
    <updated>2019-02-17T04:28:47.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述开放API接口安全处理策略（有道云笔记迁移）</p></blockquote><h1 id="一、开放API接口定义"><a href="#一、开放API接口定义" class="headerlink" title="一、开放API接口定义"></a>一、开放API接口定义</h1><blockquote><p>顾名思义，开放出来给其他人调用的API接口就是开放API接口。例如，短信接口、邮件接口。</p></blockquote><hr><h1 id="二、开放API的弱点"><a href="#二、开放API的弱点" class="headerlink" title="二、开放API的弱点"></a>二、开放API的弱点</h1><h2 id="1-数据窃取"><a href="#1-数据窃取" class="headerlink" title="1. 数据窃取"></a>1. 数据窃取</h2><blockquote><p>用户的密码等信息被不轨之人窃取，登录账号发布敏感信息，盗刷等。</p></blockquote><h2 id="2-数据篡改"><a href="#2-数据篡改" class="headerlink" title="2. 数据篡改"></a>2. 数据篡改</h2><blockquote><p>提交的数据被抓包后进行篡改后再提交。</p></blockquote><h2 id="3-数据泄露"><a href="#3-数据泄露" class="headerlink" title="3. 数据泄露"></a>3. 数据泄露</h2><blockquote><p>爬虫将业务数据甚至核心数据抓取，直接或间接造成损失。</p></blockquote><hr><h1 id="三、开放API解决方案"><a href="#三、开放API解决方案" class="headerlink" title="三、开放API解决方案"></a>三、开放API解决方案</h1><h2 id="1-RSA-DES-加密"><a href="#1-RSA-DES-加密" class="headerlink" title="1. RSA/DES 加密"></a>1. RSA/DES 加密</h2><h3 id="对称加密（DES、AES）"><a href="#对称加密（DES、AES）" class="headerlink" title="对称加密（DES、AES）"></a>对称加密（DES、AES）</h3><ul><li>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</li><li>对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。</li><li>对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</li></ul><h3 id="非对称加密（RSA）"><a href="#非对称加密（RSA）" class="headerlink" title="非对称加密（RSA）"></a>非对称加密（RSA）</h3><ul><li>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</li><li>目前最常用的非对称加密算法是RSA算法，是Rivest, Shamir, 和Adleman于1978年发明。</li><li>RSA可以用于加密和签名：</li></ul><p><img src="/2018/12/10/开放API接口安全处理/20181210231535322.png" alt></p><p><img src="/2018/12/10/开放API接口安全处理/20181210231740664.png" alt></p><ul><li>HTTPS即用到了对称加密也用到了非对称加密（收费，服务器开销大，性能略低）</li><li>RSA加密 Java 实现：</li></ul><h2 id="2-MD5-混淆算法"><a href="#2-MD5-混淆算法" class="headerlink" title="2. MD5 混淆算法"></a>2. MD5 混淆算法</h2><ul><li>是一种消息摘要算法，一种被广泛使用的密码散列函数，可以产生出一个128位的散列值，用于确保信息传输完整一致，防止篡改。</li><li>不可逆的</li><li>存储一些永远不需要还原的数据，如 密码、MAC地址、IMEI</li><li>通常配合salt 加盐来加密</li><li>现在可以破解的是 通过一个彩虹表碰撞进行暴力破解</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>接口文档规定，接口哪些字段（id+名称）进行MD5+salt 加密传输到后台，同样后台也按照相关规则计算，然后比对匹配</li></ul><h2 id="3-TOKEN-令牌"><a href="#3-TOKEN-令牌" class="headerlink" title="3. TOKEN 令牌"></a>3. TOKEN 令牌</h2><ul><li>略</li></ul><hr><h1 id="四、接口实战经验"><a href="#四、接口实战经验" class="headerlink" title="四、接口实战经验"></a>四、接口实战经验</h1><ol><li>不要用自增序列</li><li>日志加完整，防背锅</li><li>短信接口一定要加图形验证码、人机验证码，业务判断，尤其是注册接口（没有用户的任何信息）</li><li>幂等性（ 提交一次和多次结果是一样的）</li><li>时间戳（有效时间）</li></ol><blockquote><p>先获取服务器时间，当作参数一起MD5，然后后台校验MD5成功之后，判断有效时间是否在30s之内。</p></blockquote><hr><h1 id="五、关于RSA加密、解密疑惑"><a href="#五、关于RSA加密、解密疑惑" class="headerlink" title="五、关于RSA加密、解密疑惑"></a>五、关于RSA加密、解密疑惑</h1><ul><li>还有公钥和私钥到底哪个才是用来加密和哪个用来解密？</li><li>不要去硬记。</li><li>你只要想：既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</li><li>很多人没真正理解RSA的原理，两个大质数(p,q)乘积(n)难以逆向求解，所以pq是对等的，公钥和私钥也是对等的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述开放API接口安全处理策略（有道云笔记迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、开放API接口定义&quot;&gt;&lt;a href=&quot;#一、开放API接口定义&quot; class=&quot;headerlink&quot; title=&quot;一、开放API接口
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制笔记</title>
    <link href="https://jiaohongwei.github.io/2018/11/30/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiaohongwei.github.io/2018/11/30/Java反射机制笔记/</id>
    <published>2018-11-30T02:41:08.000Z</published>
    <updated>2019-02-16T15:03:36.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述-amp-应用场景"><a href="#一、概述-amp-应用场景" class="headerlink" title="一、概述&amp;应用场景"></a>一、概述&amp;应用场景</h1><ul><li>Java反射机制是在运行状态中，对于任意一个类（Class）文件，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意一个方法和属性；</li><li>这种动态获取的信息以及动态调用对象的方法的功能成为Java语言的反射机制。</li></ul><blockquote><p>简单说就是动态获取类中信息就是反射机制。</p></blockquote><blockquote><p>可以理解为对类的解剖。</p></blockquote><hr><h1 id="二、细节-amp-Class对象"><a href="#二、细节-amp-Class对象" class="headerlink" title="二、细节&amp;Class对象"></a>二、细节&amp;Class对象</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Class&#123;</span><br><span class="line">    提供获取字节码文件中的内容。</span><br><span class="line">    比如：</span><br><span class="line">    名称，字段，构造函数，一般函数</span><br><span class="line">&#125;</span><br><span class="line">// 该类就可以获取字节码文件中的所有内容，那么反射就是依靠该类完成的。</span><br></pre></td></tr></table></figure><ul><li>想要对一个类文件进行解刨，只需要获取到该类的字节码文件对象即可。</li></ul><blockquote><p>java.lang.Class<t> </t></p></blockquote><ul><li>Class类的类表示正在运行的Java应用程序中的类和接口。 </li><li>枚举是一种类，一个注释是一种界面。 每个数组也属于一个反映为类对象的类，该对象由具有相同元素类型和维数的所有数组共享。 </li><li>原始Java类型（ boolean ， byte ， char ， short ， int ， long ， float和double ），和关键字void也表示为类对象。 </li><li>类没有公共构造函数。 相反， 类对象由Java虚拟机自动构建，因为加载了类，并且通过调用类加载器中的defineClass方法。</li></ul><hr><h1 id="三、获取Class对象的三种方式"><a href="#三、获取Class对象的三种方式" class="headerlink" title="三、获取Class对象的三种方式"></a>三、获取Class对象的三种方式</h1><p>要想对字节码文件进行解刨，必须要有字节码文件对象</p><ol><li>Object类中的getClass方法</li><li>通过对象静态属性 .class来获取对应的Class对象</li><li>只要通过给定类的字符串名称就可以获取该类，更为拓展</li></ol><h2 id="1-object-getClass"><a href="#1-object-getClass" class="headerlink" title="1.  object.getClass()"></a>1.  object.getClass()</h2><blockquote><p>创建Person类</p></blockquote><p>必须要明确具体的类，并且要创建对象，麻烦。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hw.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/11/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"... show run ..."</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"privateMethod run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paramMethod</span><span class="params">(String str, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"paramMethod run..."</span> + str + <span class="string">": "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"staticMethod run ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"person run ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">"person param run ... name="</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试用例</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取Class对象的三种方式</span><br><span class="line"> * 1.Object类中的getClass()方法，必须要明确具体的类，并且要创建对象，麻烦。</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getClassObject_1() &#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    Class clazz = person.getClass();</span><br><span class="line"></span><br><span class="line">    Person person1 = new Person();</span><br><span class="line">    Class clazz1 = person1.getClass();</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz == clazz1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130000917879.png" alt></p><h2 id="2-Object-class"><a href="#2-Object-class" class="headerlink" title="2. Object.class"></a>2. Object.class</h2><p>相对简单，但是还是需要先明确类中的静态成员。不够拓展。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过对象静态属性 .class来获取对应的Class对象</span><br><span class="line"> */</span><br><span class="line">public void getClassObject_2() &#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Class-forName-className"><a href="#3-Class-forName-className" class="headerlink" title="3. Class.forName(className)"></a>3. Class.forName(className)</h2><p>这种方法只要有名称即可，更为方便，拓展性更强。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 方式三：只要通过给定类的字符串名称就可以获取该类，更为拓展，forName</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getClassObject_3() throws ClassNotFoundException &#123;</span><br><span class="line">    String className = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    Class clazz = Class.forName(className);</span><br><span class="line">    System.out.println(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130002216418.png" alt></p><hr><h1 id="四、获取Class中的构造函数"><a href="#四、获取Class中的构造函数" class="headerlink" title="四、获取Class中的构造函数"></a>四、获取Class中的构造函数</h1><h2 id="1-new创建对象"><a href="#1-new创建对象" class="headerlink" title="1. new创建对象"></a>1. new创建对象</h2><ul><li>早期创建对象,先根据被new的类的名称找寻该类的字节码文件，并加载进内存，并创建该字节码文件对象，并接着创建该接文件的对应的Person对象</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.hw.bean.Person p = new com.hw.bean.Person();</span><br></pre></td></tr></table></figure><h2 id="2-反射创建对象"><a href="#2-反射创建对象" class="headerlink" title="2. 反射创建对象"></a>2. 反射创建对象</h2><ul><li>找寻该名称类文件，并加载进内存，调用newInstance() 创建由此 类对象表示的类的新实例。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createNewObject_1() throws Exception &#123;</span><br><span class="line">    // 早期创建对象,先根据被new的类的名称找寻该类的字节码文件，并加载进内存，</span><br><span class="line">    // 并创建该字节码文件对象，并接着创建该接文件的对应的Person对象</span><br><span class="line">    com.hw.bean.Person p = new com.hw.bean.Person();</span><br><span class="line"></span><br><span class="line">    // 现在</span><br><span class="line">    String name = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    // 找寻该名称类文件，并加载进内存，并产生Class对象</span><br><span class="line">    Class clazz = Class.forName(name);</span><br><span class="line">    // 通过空参构造器获取实例</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/30/Java反射机制笔记/20181130004030863.png" alt></p><ul><li>当获取指定名称对应类中的所体现的对象时，而该对象初始化不是用空参数构造该怎么办呢？</li><li>既然是通过指定的构造函数，进行对象的初始化，所以应该先获取到构造函数。</li></ul><h2 id="3-获取Class中的构造函数"><a href="#3-获取Class中的构造函数" class="headerlink" title="3. 获取Class中的构造函数"></a>3. 获取Class中的构造函数</h2><blockquote><p>getConstructor(类&lt;?&gt;… parameterTypes) </p></blockquote><ul><li>返回一个 Constructor对象，该对象反映 Constructor对象表示的类的指定的公共 类函数。 </li><li>parameterTypes参数是以声明顺序标识构造函数的形式参数类型的类对象的数组。</li><li>如果此类对象表示在非静态上下文中声明的内部类，则形式参数类型将显式包围实例作为第一个参数。</li><li>反映的构造是这样表示的类的公共构造类对象，其形式参数类型匹配那些由指定的parameterTypes 。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createNewObject_2() throws Exception &#123;</span><br><span class="line">    String name = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    Class clazz = Class.forName(name);</span><br><span class="line">    // 获取指定方法参数的构造对象</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">    // 通过该构造器对象的newInstance()方法进行对象的初始化</span><br><span class="line">    Object obj = constructor.newInstance(&quot;小明&quot;, 22);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><p><img src="/2018/11/30/Java反射机制笔记/20181130005233982.png" alt></p><hr><h1 id="五、获取Class中的字段"><a href="#五、获取Class中的字段" class="headerlink" title="五、获取Class中的字段"></a>五、获取Class中的字段</h1><h2 id="1-getField-String-name"><a href="#1-getField-String-name" class="headerlink" title="1. getField(String name)"></a>1. getField(String name)</h2><ul><li>返回一个 Field对象，它反映此表示的类或接口的指定公共成员字段 类对象。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取字节码文件的字段</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Field name = clazz.getField(&quot;name&quot;);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130005820538.png" alt></p><p>报错，原因是字段是私有的。</p><p>要反映的字段由以下算法确定。 让C成为由该对象表示的类或接口： </p><ul><li>如果C声明一个具有指定名称的公共字段，那就是要反映的字段。 </li><li>如果在上述步骤1中没有找到字段，则将该算法递归地应用于C的每个直接超级接口。直接超级接口按照它们被声明的顺序被搜索。 </li><li>如果在上面的步骤1和2中没有找到字段，并且C具有超类S，则该算法在S上递归地调用。如果C没有超类，则抛出NoSuchFieldException 。 </li></ul><h2 id="2-getDeclaredField-String-name"><a href="#2-getDeclaredField-String-name" class="headerlink" title="2. getDeclaredField(String name)"></a>2. getDeclaredField(String name)</h2><ul><li>只获取本类 但包含私有</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line"></span><br><span class="line">    Field field = // clazz.getField(&quot;name&quot;);</span><br><span class="line">            clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    Object age = field.get(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130010456310.png" alt></p><p>还是报错，不能访问私有的</p><h2 id="3-AccessibleObject-属性"><a href="#3-AccessibleObject-属性" class="headerlink" title="3. AccessibleObject 属性"></a>3. AccessibleObject 属性</h2><ul><li>AccessibleObject类是Field，Method和Constructor对象的基类。 它提供了将反射对象标记为在使用它时抑制默认Java语言访问控制检查的功能。</li><li>当使用Fields，Methods或Constructors来设置或获取字段，调用方法，或创建和初始化新的类实例时，执行访问检查（对于public，默认（包）访问，受保护和私有成员）。</li></ul><blockquote><p>setAccessible(boolean flag)  暴力访问</p></blockquote><ul><li>将此对象的 accessible标志设置为指示的布尔值。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line"></span><br><span class="line">    Field field = // clazz.getField(&quot;name&quot;);</span><br><span class="line">            clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">    // 对私有字段的访问取消权限检查。暴力访问</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    // 对字段赋值</span><br><span class="line">    field.set(instance,&quot;张四&quot;);</span><br><span class="line">    Object name = field.get(instance);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130011330038.png" alt></p><hr><h1 id="六、获取Class中的方法"><a href="#六、获取Class中的方法" class="headerlink" title="六、获取Class中的方法"></a>六、获取Class中的方法</h1><h2 id="1-getMethods"><a href="#1-getMethods" class="headerlink" title="1. getMethods()"></a>1. getMethods()</h2><ul><li><p>获取的都是共有的方法（包括父类）</p></li><li><p>返回包含一个数组 方法对象反射由此表示的类或接口的所有公共方法 类对象，包括那些由类或接口和那些从超类和超接口继承的声明。</p></li><li>如果此类对象表示具有多个具有相同名称和参数类型但具有不同返回类型的公共方法的类型，则返回的数组对于每个此类方法都有一个方法对象。 </li><li>如果此类对象表示与类初始化方法的类型<clinit> ，则返回的阵列不具有相应的方法对象。 </clinit></li><li>如果此类对象表示一个数组类型，则返回的阵列具有方法对于每个由阵列类型从继承的公共方法对象Object 。 它不包含方法对象clone() 。 </li><li>如果此类对象表示一个接口，那么返回的数组不包含任何隐含声明的方法，从Object 。因此，如果在此接口或其任何超级接口中没有显式声明方法，则返回的数组的长度为0.（注意，表示类的类对象始终具有从Object公共方法）。 </li><li>如果此类对象表示原始类型或空值，则返回的数组的长度为0。 </li><li>由此类对象表示的类或接口的超级接口中声明的静态方法不被视为类或接口的成员。 </li><li>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取指定Class中的公共函数</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getMethodDemo() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130012039348.png" alt></p><h2 id="2-getDeclaredMethods"><a href="#2-getDeclaredMethods" class="headerlink" title="2. getDeclaredMethods()"></a>2. getDeclaredMethods()</h2><ul><li>获取本类中的所有的方法（包含私有的）</li><li>返回包含一个数组方法对象反射的类或接口的所有声明的方法，通过此表示类对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。 </li><li>如果此类对象表示具有多个具有相同名称和参数类型但具有不同返回类型的声明方法的类型，则返回的数组对于每个此类方法都有一个方法对象。 </li><li>如果此类对象表示具有类初始化方法的类型<clinit> ，则返回的阵列不具有相应的方法对象。 </clinit></li><li>如果此类对象表示没有声明方法的类或接口，则返回的数组的长度为0。 </li><li>如果这个类对象表示一个数组类型，一个基本类型，或者是void，则返回的数组的长度为0。 </li><li>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_2() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130012438582.png" alt></p><h2 id="3-getMethod-String-name-类-lt-gt-…-parameterTypes"><a href="#3-getMethod-String-name-类-lt-gt-…-parameterTypes" class="headerlink" title="3. getMethod(String name, 类&lt;?&gt;… parameterTypes)"></a>3. getMethod(String name, 类&lt;?&gt;… parameterTypes)</h2><ul><li>获取单个方法</li><li>返回一个方法对象，它反映此表示的类或接口的指定公共成员方法类对象。 </li><li>name参数是一个String它指定了所需方法的简单名称。 </li><li>parameterTypes参数是以声明顺序标识方法的形式参数类型的类对象的数组。 </li><li>如果parameterTypes是null ，它被视为一个空数组。 </li></ul><blockquote><p>方法无参 方式一：使用无参构造器（默认） method.invoke(o, null)</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_3() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    // 获取空参的一般方法</span><br><span class="line">    Method method = clazz.getMethod(&quot;show&quot;, null);</span><br><span class="line">    Object o = clazz.newInstance();</span><br><span class="line">    method.invoke(o, null);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130013410485.png" alt></p><blockquote><p>方法无参 方式二：使用有参构造器  method.invoke(o, null)</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_4() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    // 获取空参的一般方法</span><br><span class="line">    Method method = clazz.getMethod(&quot;show&quot;, null);</span><br><span class="line">    // 获取带参构造器</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    Object o = constructor.newInstance(&quot;小明&quot;, 12);</span><br><span class="line">    method.invoke(o, null);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130013645030.png" alt></p><blockquote><p>方法有参 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_5() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method method = clazz.getMethod(&quot;paramMethod&quot;, String.class, int.class);</span><br><span class="line">    // 获取带参构造器</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    Object o = constructor.newInstance(&quot;小明&quot;, 12);</span><br><span class="line">    method.invoke(o, &quot;张三&quot;, 18);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130014202027.png" alt></p><hr><h1 id="七、源码"><a href="#七、源码" class="headerlink" title="七、源码"></a>七、源码</h1><p>本章节源码: <a href="https://github.com/JiaoHongwei/Reflection" target="_blank" rel="noopener">ReflectDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述-amp-应用场景&quot;&gt;&lt;a href=&quot;#一、概述-amp-应用场景&quot; class=&quot;headerlink&quot; title=&quot;一、概述&amp;amp;应用场景&quot;&gt;&lt;/a&gt;一、概述&amp;amp;应用场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java反射机制是在运行状态中，对于任意
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
      <category term="反射" scheme="https://jiaohongwei.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux cp/rm/mv强制覆盖</title>
    <link href="https://jiaohongwei.github.io/2017/08/18/Linux-cp-rm-mv%E5%BC%BA%E5%88%B6%E8%A6%86%E7%9B%96/"/>
    <id>https://jiaohongwei.github.io/2017/08/18/Linux-cp-rm-mv强制覆盖/</id>
    <published>2017-08-18T10:34:00.000Z</published>
    <updated>2019-02-17T03:44:45.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述Linux下的cp/rm/mv强制覆盖以及在Java中的调用（博客园文章迁移）</p></blockquote><h1 id="一、Linux下的cp-rm-mv强制覆盖"><a href="#一、Linux下的cp-rm-mv强制覆盖" class="headerlink" title="一、Linux下的cp/rm/mv强制覆盖"></a>一、Linux下的cp/rm/mv强制覆盖</h1><h2 id="1-反斜杠（-）临时取消别名"><a href="#1-反斜杠（-）临时取消别名" class="headerlink" title="1. 反斜杠（\）临时取消别名"></a>1. 反斜杠（\）临时取消别名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]# \cp filename new/filename   </span><br><span class="line">[root@fz ~]#</span><br></pre></td></tr></table></figure><h2 id="2-unalias-取消别名"><a href="#2-unalias-取消别名" class="headerlink" title="2. unalias 取消别名"></a>2. unalias 取消别名</h2><blockquote><p>注意：这只是临时取消cp的别名，不是永久的</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# unalias cp   </span><br><span class="line">[root@localhost ~]# cp filename new/filename   </span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h2 id="3-修改默认配置文件"><a href="#3-修改默认配置文件" class="headerlink" title="3. 修改默认配置文件"></a>3. 修改默认配置文件</h2><blockquote><p>输入alias命令，看到系统内部使用的是cp、mv、rm -i 所以怎么输入都是提示覆盖。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]#</span><br><span class="line">[root@fz ~]# alias</span><br><span class="line">alias cdd=&apos;cd /home/data/android/&apos;</span><br><span class="line">alias cp=&apos;cp -i&apos;</span><br><span class="line">alias l=&apos;ls -la&apos;</span><br><span class="line">alias l.=&apos;ls -d .* --color=auto&apos;</span><br><span class="line">alias ll=&apos;ls -l --color=auto&apos;</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br><span class="line">alias mv=&apos;mv -i&apos;</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias tf=&apos;tail -f &apos;</span><br><span class="line">alias vc=&apos;vim ~/.bash_profile&apos;</span><br><span class="line">alias vs=&apos;source ~/.bash_profile&apos;</span><br><span class="line">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br></pre></td></tr></table></figure><blockquote><p>修改 ~/.bashrc ，在 “alias cp=’cp -i’ ”前添加<code>#</code>号注释后即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz test]# vi ~/.bashrc </span><br><span class="line"># .bashrc</span><br><span class="line"></span><br><span class="line"># User specific aliases and functions</span><br><span class="line"></span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">#alias cp=&apos;cp -i&apos;</span><br><span class="line">alias mv=&apos;mv -i&apos;</span><br><span class="line"></span><br><span class="line"># Source global definitions</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>重启或者执行 source ~/.bashrc 让命令生效</p></blockquote><h2 id="4-yes指令-管道-自动输入yes"><a href="#4-yes指令-管道-自动输入yes" class="headerlink" title="4. yes指令+管道 自动输入yes"></a>4. yes指令+管道 自动输入yes</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]# yes | cp filename new/filename   </span><br><span class="line">cp: overwrite `new/filename&apos;? [root@localhost ~]#</span><br></pre></td></tr></table></figure><hr><h1 id="二、Java后台调用Linux命令实现"><a href="#二、Java后台调用Linux命令实现" class="headerlink" title="二、Java后台调用Linux命令实现"></a>二、Java后台调用Linux命令实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void copyIcon() throws IOException, InterruptedException &#123;</span><br><span class="line">      Runtime r = Runtime.getRuntime();</span><br><span class="line">      String cmd_copy = &quot;\\cp -rf temp/AppIcon/*  icon/&quot;;    //copy并覆盖</span><br><span class="line">      String[] cmds = new String[]&#123;&quot;sh&quot;,&quot;-c&quot;,cmd_copy&#125;;</span><br><span class="line">      Process p = r.exec(cmds);</span><br><span class="line">      int result = p.waitFor();</span><br><span class="line">      if (result == 0)&#123;   //表示正常结束</span><br><span class="line">          logger.error(&quot;【copy appIcon 成功】&quot;);</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">          logger.error(&quot;【copy appIcon 失败】&quot;+cmd_copy);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述Linux下的cp/rm/mv强制覆盖以及在Java中的调用（博客园文章迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Linux下的cp-rm-mv强制覆盖&quot;&gt;&lt;a href=&quot;#一、Linux下的cp-rm-mv强制覆盖
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://jiaohongwei.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Oracle CLOB 笔记</title>
    <link href="https://jiaohongwei.github.io/2017/08/18/Oracle-CLOB-%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiaohongwei.github.io/2017/08/18/Oracle-CLOB-笔记/</id>
    <published>2017-08-18T06:36:19.000Z</published>
    <updated>2019-02-17T03:29:34.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述Oracle的CLOB大数据字段类型（博客园文章迁移）</p></blockquote><h1 id="一、Oracle中的varchar2类型"><a href="#一、Oracle中的varchar2类型" class="headerlink" title="一、Oracle中的varchar2类型"></a>一、Oracle中的varchar2类型</h1><ul><li>我们在Oracle数据库存储的字符数据一般是用VARCHAR2。VARCHAR2既分PL/SQL Data Types中的变量类型，也分Oracle Database中的字段类型，不同场景的最大长度不同。</li><li>在Oracle Database中，VARCHAR2 字段类型，最大值为4000；PL/SQL中 VARCHAR2 变量类型，最大字节长度为32767。</li><li>当 VARCHAR2 容纳不下我们需要存储的信息时，就出来的Oracle的大数据类型LOB( Large Object，大型对象)。</li></ul><hr><h1 id="二、Oarcle中的LOB类型"><a href="#二、Oarcle中的LOB类型" class="headerlink" title="二、Oarcle中的LOB类型"></a>二、Oarcle中的LOB类型</h1><ul><li>在Oracle中，LOB（Large Object，大型对象）类型的字段现在用得越来越多了。因为这种类型的字段，容量大（最多能容纳4GB的数据），且一个表中可以有多个这种类型的字段，很灵活，适用于数据量非常大的业务领域（如图象、档案等）。</li><li>LOB类型分为BLOB和CLOB两种：BLOB即二进制大型对象（Binary Large Object），适用于存贮非文本的字节流数据（如程序、图象、影音等）。</li><li>而CLOB，即字符型大型对象（Character Large Object），则与字符集相关，适于存贮文本型的数据（如历史档案、大部头著作等）。</li></ul><hr><h1 id="三、DB中使用CLOB类型字段"><a href="#三、DB中使用CLOB类型字段" class="headerlink" title="三、DB中使用CLOB类型字段"></a>三、DB中使用CLOB类型字段</h1><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h2><blockquote><p>（使用sql或者直接在PL/SQL客户端创建），字段类型CLOB</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create table</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TEMP</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">name</span>      VARCHAR2(<span class="number">200</span>),</span><br><span class="line">  age       <span class="built_in">NUMBER</span>,</span><br><span class="line">  temp_clob <span class="keyword">CLOB</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">tablespace</span> INSIGHTDATA3_TS</span><br><span class="line">  pctfree <span class="number">10</span></span><br><span class="line">  <span class="keyword">initrans</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">maxtrans</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">storage</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">initial</span> <span class="number">160</span>K</span><br><span class="line">    <span class="keyword">next</span> <span class="number">1</span>M</span><br><span class="line">    <span class="keyword">minextents</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">maxextents</span> <span class="keyword">unlimited</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h2 id="2-增删改查"><a href="#2-增删改查" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h2><p>先看一下使用普通方式的sql操作CLOB类型：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.name, t.temp_clob <span class="keyword">FROM</span> temp t; <span class="comment">--普通查询 INSERT INTO temp t VALUES ('Grand.Jon', 22, '加入博客园的第一天');</span></span><br></pre></td></tr></table></figure><p>查询因为不是varchar2类型，所以普通查询看不到CLOB类型的字段内容，结果如下</p><p><img src="/2017/08/18/Oracle-CLOB-笔记/20170818131552506.png" alt></p><p>而普通插入操作也会因为Oracle的隐式转换，默认把字符串转换成varchar2类型，一旦字符串内容超过varchar2的最大限度就会报会报ora-01704（字符串太长）错误。</p><p>正确操作：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用PL/SQL语法，采取绑定变量的方式解决，而不是直接拼接SQL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">       V_LANG <span class="keyword">CLOB</span> := <span class="string">'待插入的海量字符串'</span>;</span><br><span class="line">       </span><br><span class="line">       V_UPDATE CLOB := '更新的海量字符串';</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp t <span class="keyword">VALUES</span> (<span class="string">'Grand.Jon'</span>, <span class="number">22</span>, V_LANG);        <span class="comment">--增加</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> temp t <span class="keyword">SET</span> t.temp_clob = V_UPDATE <span class="keyword">WHERE</span> <span class="keyword">rownum</span> = <span class="number">1</span>;  <span class="comment">--修改</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> t.NAME, dbms_lob.substr(t.temp_clob) <span class="keyword">FROM</span> TEMP t;    <span class="comment">--查询　　将CLOB转成字符类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">DELETE</span> temp t <span class="keyword">WHERE</span> <span class="keyword">rownum</span> = <span class="number">1</span>;                             <span class="comment">--按列删除　　</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><blockquote><p>对CLOB的操作我们在存储过程中基本上使用 dbms_lob 中 substr , append , write 等方法。</p></blockquote><p>dbms_lob 方法总结</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">dbms_lob.createtemporary(V_SQL,true);     <span class="comment">--创建一个临时clob，用来存储拼接的sql</span></span><br><span class="line">dbms_lob.write(v_SQL,'写入信息');          <span class="comment">--写入操作</span></span><br><span class="line">dbms_lob.append(v_SQL,',');               <span class="comment">--拼接clob</span></span><br><span class="line">dbms_lob.substr(v_SQL);                   <span class="comment">--截取clob，不传参数就是全部读取</span></span><br><span class="line">dbms_lob.freetemporary(v_SQL);            <span class="comment">--释放clob</span></span><br></pre></td></tr></table></figure><p>查询结果如下：</p><p><img src="/2017/08/18/Oracle-CLOB-笔记/20170818133801834.png" alt></p><hr><h1 id="四、在存储过程中使用CLOB类型实例"><a href="#四、在存储过程中使用CLOB类型实例" class="headerlink" title="四、在存储过程中使用CLOB类型实例"></a>四、在存储过程中使用CLOB类型实例</h1><blockquote><p>需求：以开发的存储过程为例，需要循环遍历时间范围拼接sql，将时间日期按列反转（pivot），如果时间太长（1年以上）sql语句（varchar2）就会超出范围报错，这时候就需要使用CLOB来存储拼接的sql。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PROCEDURE P_AND_CPT_RATIOOTH_APP_BAK2_N(</span><br><span class="line">            V_APPIDS IN VARCHAR2,</span><br><span class="line">            V_TYPE IN VARCHAR2,</span><br><span class="line">            V_CHANNEL IN VARCHAR2,</span><br><span class="line">            V_TABLE IN VARCHAR2,</span><br><span class="line">            V_START IN VARCHAR2,</span><br><span class="line">            V_END IN VARCHAR2,</span><br><span class="line">            RESULT OUT mycursor</span><br><span class="line">) IS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">V_SQL CLOB;</span><br><span class="line">V_SQLWHERE VARCHAR2(32767) default  '';</span><br><span class="line">V_SQLWHERE_CHANNEL VARCHAR2(32767) default '';</span><br><span class="line">V_SQL_DATES  CLOB;</span><br><span class="line">V_Sdate  DATE;</span><br><span class="line">V_Edate  DATE;</span><br><span class="line">V_TABLE_DATE VARCHAR2(50);</span><br><span class="line">V_TABLE_TYPE VARCHAR2(50);</span><br><span class="line">V_START_DATE VARCHAR2(50);</span><br><span class="line">V_END_DATE   VARCHAR2(50);</span><br><span class="line"></span><br><span class="line">V_DAY VARCHAR2(50);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">select</span> column_name <span class="keyword">into</span> V_TABLE_DATE <span class="keyword">from</span> user_tab_columns <span class="keyword">where</span> table_name=<span class="string">''</span>||V_TABLE||<span class="string">''</span> <span class="keyword">and</span> column_id=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">select</span> column_name <span class="keyword">into</span> V_TABLE_TYPE <span class="keyword">from</span> user_tab_columns <span class="keyword">where</span> table_name=<span class="string">''</span>||V_TABLE||<span class="string">''</span> <span class="keyword">and</span> column_id=<span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">    dbms_lob.createtemporary(V_SQL,true);<span class="comment">--创建一个临时lob</span></span><br><span class="line">    dbms_lob.createtemporary(V_SQL_DATES,true);<span class="comment">--创建一个临时lob</span></span><br><span class="line">    </span><br><span class="line">    IF V_APPIDS is NOT NULL THEN</span><br><span class="line">       V_SQLWHERE := 'AND t.appid in ('||V_APPIDS||')';</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">    IF V_CHANNEL IS NOT NULL THEN</span><br><span class="line">       V_SQLWHERE_CHANNEL := 'AND t.channel = '''||V_CHANNEL||'''';</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    IF V_TABLE_DATE = 'MON' THEN</span><br><span class="line">       V_START_DATE := SUBSTR(V_START,0,6);</span><br><span class="line">       V_END_DATE :=  SUBSTR(V_END,0,6);</span><br><span class="line">       v_sdate := to_date(V_START_DATE, 'yyyymm');</span><br><span class="line">       v_edate := to_date(V_END_DATE, 'yyyymm');</span><br><span class="line">       </span><br><span class="line">        WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">              dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymm'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">        IF v_sdate != v_edate THEN</span><br><span class="line">              dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">        v_sdate := add_months(v_sdate,1);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    ELSE  <span class="comment">--周和日 类型 都是 DAY</span></span><br><span class="line">      </span><br><span class="line">       v_sdate := to_date(V_START, 'yyyymmdd');</span><br><span class="line">       v_edate := to_date(V_END, 'yyyymmdd');</span><br><span class="line">       V_END_DATE :=  V_END;</span><br><span class="line">       </span><br><span class="line">       IF SUBSTR(V_TYPE,0,1)='d' THEN</span><br><span class="line">            V_START_DATE := to_char(v_sdate, 'yyyymmdd');</span><br><span class="line"></span><br><span class="line">            WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">                  dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymmdd'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">            IF v_sdate != v_edate THEN</span><br><span class="line">                  dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">            v_sdate := v_sdate+1;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">       </span><br><span class="line">       ELSIF SUBSTR(V_TYPE,0,1)='w' THEN</span><br><span class="line"></span><br><span class="line">           <span class="keyword">select</span> to_char(V_Sdate,<span class="string">'d'</span>) <span class="keyword">INTO</span> V_DAY <span class="keyword">from</span> dual;</span><br><span class="line">            IF V_DAY!=2 THEN</span><br><span class="line">             V_Sdate:=V_Sdate-7;</span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">          V_START_DATE := to_char(v_sdate, 'yyyymmdd');</span><br><span class="line"></span><br><span class="line">          WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">               <span class="keyword">select</span> to_char(V_Sdate,<span class="string">'d'</span>) <span class="keyword">INTO</span> V_DAY <span class="keyword">from</span> dual;</span><br><span class="line">              IF V_DAY=2 THEN</span><br><span class="line">                 dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymmdd'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">                 IF V_Edate-v_sdate &gt;7 THEN</span><br><span class="line">                   dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">                 <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">            v_sdate := v_sdate+1;</span><br><span class="line">           <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    dbms_lob.append(v_sql,'<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>( <span class="keyword">SELECT</span> *</span><br><span class="line">            <span class="keyword">FROM</span> <span class="string">'||V_TABLE||'</span> t</span><br><span class="line">           <span class="keyword">WHERE</span> </span><br><span class="line">                 t.<span class="string">'||V_TABLE_TYPE||'</span> = <span class="string">'''||V_TYPE||'''</span></span><br><span class="line">             <span class="keyword">AND</span> t.<span class="string">'||V_TABLE_DATE||'</span> &gt;= <span class="string">'''||V_START_DATE||'''</span></span><br><span class="line">             <span class="keyword">AND</span> t.<span class="string">'||V_TABLE_DATE||'</span> &lt;= <span class="string">'''||V_END_DATE||'''</span></span><br><span class="line">             <span class="string">'||V_SQLWHERE||'</span>         </span><br><span class="line">             <span class="string">'||V_SQLWHERE_CHANNEL||'</span> ) t1</span><br><span class="line"> </span><br><span class="line">           <span class="keyword">pivot</span>(<span class="keyword">sum</span>(MARKETSHARE)</span><br><span class="line">             <span class="keyword">for</span> <span class="string">'||V_TABLE_DATE||'</span> <span class="keyword">in</span>(<span class="string">');</span></span><br><span class="line"><span class="string">             </span></span><br><span class="line"><span class="string">    dbms_lob.append(v_sql,v_SQL_DATES);</span></span><br><span class="line"><span class="string">    dbms_lob.append(v_sql,'</span>))<span class="string">');</span></span><br><span class="line"><span class="string">    dbms_output.put_line(v_sql);      </span></span><br><span class="line"><span class="string">    OPEN result FOR v_sql;   </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">       dbms_lob.freetemporary(v_sql);--释放lob</span></span><br><span class="line"><span class="string">       dbms_lob.freetemporary(v_SQL_DATES);--释放lob</span></span><br><span class="line"><span class="string">       --dbms_output.put_line(V_SQLDATE);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      -- dbms_output.put_line(v_SQL_DATES);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--记录操作日志及错误日志</span></span><br><span class="line"><span class="string">END;</span></span><br></pre></td></tr></table></figure><hr><h1 id="五、使用Java开发操作CLOB字段"><a href="#五、使用Java开发操作CLOB字段" class="headerlink" title="五、使用Java开发操作CLOB字段"></a>五、使用Java开发操作CLOB字段</h1><h2 id="1-原生JDBC处理CLOB类型"><a href="#1-原生JDBC处理CLOB类型" class="headerlink" title="1. 原生JDBC处理CLOB类型"></a>1. 原生JDBC处理CLOB类型</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><blockquote><p>增加，一般会插入一个空的clob到数据库对应的字段,然后锁定该列，用Write将待插入字符串写入进去。</p></blockquote><ul><li>重点：这两步操作要放在同一个事务里面。具体增加的方法如下:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean save(Article article)&#123;</span><br><span class="line">    boolean result = true;</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;insert into temp values(?,?,empty_clob())&quot;;</span><br><span class="line">    //锁住该列，防止并发写入时候该字段同时被多次写入造成错误</span><br><span class="line">    String sqlClob = &quot;select temp_clob from temp t where t.name=? for update&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    Writer writer = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        conn.setAutoCommit(false);//设置不自动提交，开启事务</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setString(1,article.getName());</span><br><span class="line">        pst.setString(2,article.getAge());</span><br><span class="line">        pst.executeUpdate();</span><br><span class="line"></span><br><span class="line">        pst= conn.prepareStatement(sqlClob);</span><br><span class="line">        pst.setInt(1, article.getId());</span><br><span class="line"></span><br><span class="line">        rs = pst.executeQuery();</span><br><span class="line">        CLOB clob = null;</span><br><span class="line">        if(rs.next())&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clob = (CLOB) rs.getClob(1);</span><br><span class="line">                writer = clob.getCharacterOutputStream(); //拿到clob的字符输入流</span><br><span class="line">                writer.write(article.getContent());</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        result = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn.rollback();//当commit或者rollback后会自动释放该列的锁定</span><br><span class="line">        &#125; catch (SQLException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        conn.setAutoCommit(true);//还原</span><br><span class="line">        ConnectionUntils.close(rs, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><blockquote><p>update操作，update时候主要利用PreparedStatement的setClob方法:</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean update(String name,String content)&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;update temp set temp_clob=? where name=?&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    try &#123;</span><br><span class="line">        CLOB clob   = oracle.sql.CLOB.createTemporary(conn, false,oracle.sql.CLOB.DURATION_SESSION);</span><br><span class="line">        clob.setString(1L, content);</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setClob(1, clob);</span><br><span class="line">        pst.setString(2,name);</span><br><span class="line">        result = pst.executeUpdate();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        ConnectionUntils.close(null, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    if(result==0)</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><blockquote><p>查询就主要是从结果集ResultSet中定位到对应的字段后，往外读：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Article select(String name)&#123;</span><br><span class="line">    Article article = new Article();</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;select name,age,temp_clog from temp where name = ?&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setInt(1,id);</span><br><span class="line">        rs = pst.executeQuery();</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        if(rs.next())&#123;</span><br><span class="line">            Clob clob = rs.getClob(&quot;temp_clog&quot;);</span><br><span class="line">            Reader rd = clob.getCharacterStream();</span><br><span class="line">            char [] str = new char[12];</span><br><span class="line">            while(rd.read(str) != -1) &#123;</span><br><span class="line">                builder.append(new String(str));</span><br><span class="line">            &#125;</span><br><span class="line">            article.setContent(builder.toString());</span><br><span class="line">            article.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">            article.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        ConnectionUntils.close(rs, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    return article;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Hibernate、Mybatis框架操作"><a href="#2-Hibernate、Mybatis框架操作" class="headerlink" title="2. Hibernate、Mybatis框架操作"></a>2. Hibernate、Mybatis框架操作</h2><blockquote><p>因为框架都封装集成好了，所以我们使用的时候直接配置变量的类型为CLOB就可以。</p></blockquote><p>譬如：Mybatis</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"temp_clob"</span> <span class="attr">property</span>=<span class="string">"content"</span> <span class="attr">jdbcType</span>=<span class="string">"Clob"</span>  <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.ClobTypeHandler"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>貌似Hibernate5内部做了对应的处理，可以直接当string类型一样处理即可。</p><hr><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><blockquote><p>虽然CLOB能解决VARCHAR2字符大小的限制，但是我们的DBA们都不建议用这些来处理，可能效率问题吧，大的文件应该放在服务器上，然后Database中存响应地址即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述Oracle的CLOB大数据字段类型（博客园文章迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Oracle中的varchar2类型&quot;&gt;&lt;a href=&quot;#一、Oracle中的varchar2类型&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://jiaohongwei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Oracle" scheme="https://jiaohongwei.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Java Socket编程【转】</title>
    <link href="https://jiaohongwei.github.io/2017/03/06/Java-Socket%E7%BC%96%E7%A8%8B/"/>
    <id>https://jiaohongwei.github.io/2017/03/06/Java-Socket编程/</id>
    <published>2017-03-06T06:29:46.000Z</published>
    <updated>2019-02-17T06:52:27.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java-Socket简介"><a href="#一、Java-Socket简介" class="headerlink" title="一、Java Socket简介"></a>一、Java Socket简介</h1><blockquote><p>对于Java Socket编程而言，有两个概念，一个是ServerSocket，一个是Socket。服务端和客户端之间通过Socket建立连接，之后它们就可以进行通信了。首先ServerSocket将在服务端监听某个端口，当发现客户端有Socket来试图连接它时，它会accept该Socket的连接请求，同时在服务端建立一个对应的Socket与之进行通信。这样就有两个Socket了，客户端和服务端各一个。</p></blockquote><blockquote><p>对于Socket之间的通信其实很简单，服务端往Socket的输出流里面写东西，客户端就可以通过Socket的输入流读取对应的内容。Socket与Socket之间是双向连通的，所以客户端也可以往对应的Socket输出流里面写东西，然后服务端对应的Socket的输入流就可以读出对应的内容。</p></blockquote><h1 id="二、服务端与客户端通信的例子"><a href="#二、服务端与客户端通信的例子" class="headerlink" title="二、服务端与客户端通信的例子"></a>二、服务端与客户端通信的例子</h1><h2 id="1-客户端写服务端读"><a href="#1-客户端写服务端读" class="headerlink" title="1. 客户端写服务端读"></a>1. 客户端写服务端读</h2><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常信息都往外抛  </span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">8899</span>;  </span><br><span class="line">      <span class="comment">//定义一个ServerSocket监听在端口8899上  </span></span><br><span class="line">      ServerSocket server = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">      <span class="comment">//server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span></span><br><span class="line">      Socket socket = server.accept();  </span><br><span class="line">      <span class="comment">//跟客户端建立好连接之后，我们就可以获取socket的InputStream，并从中读取客户端发过来的信息了。  </span></span><br><span class="line">      Reader reader = <span class="keyword">new</span> InputStreamReader(socket.getInputStream());  </span><br><span class="line">      <span class="keyword">char</span> chars[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];  </span><br><span class="line">      <span class="keyword">int</span> len;  </span><br><span class="line">      StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">      <span class="keyword">while</span> ((len=reader.read(chars)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">         sb.append(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(<span class="string">"from client: "</span> + sb);  </span><br><span class="line">      reader.close();  </span><br><span class="line">      socket.close();  </span><br><span class="line">      server.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>服务端从Socket的InputStream中读取数据的操作也是阻塞式的，如果从输入流中没有读取到数据程序会一直在那里不动，直到客户端往Socket的输出流中写入了数据，或关闭了Socket的输出流。当然，对于客户端的Socket也是同样如此。在操作完以后，整个程序结束前记得关闭对应的资源，即关闭对应的IO流和Socket。</p></blockquote><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">      //为了简单起见，所有的异常都直接往外抛  </span><br><span class="line">      String host = &quot;127.0.0.1&quot;;  //要连接的服务端IP地址  </span><br><span class="line">      int port = 8899;   //要连接的服务端对应的监听端口  </span><br><span class="line">      //与服务端建立连接  </span><br><span class="line">      Socket client = new Socket(host, port);  </span><br><span class="line">      //建立连接后就可以往服务端写数据了  </span><br><span class="line">      Writer writer = new OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Server.&quot;);  </span><br><span class="line">      writer.flush();//写完后要记得flush  </span><br><span class="line">      writer.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于客户端往Socket的输出流里面写数据传递给服务端要注意一点，如果写操作之后程序不是对应着输出流的关闭，而是进行其他阻塞式的操作（比如从输入流里面读数据），记住要flush一下，只有这样服务端才能收到客户端发送的数据，否则可能会引起两边无限的互相等待。在稍后讲到客户端和服务端同时读和写的时候会说到这个问题。</p></blockquote><h2 id="2-客户端和服务端同时读和写"><a href="#2-客户端和服务端同时读和写" class="headerlink" title="2. 客户端和服务端同时读和写"></a>2. 客户端和服务端同时读和写</h2><h3 id="服务端代码-1"><a href="#服务端代码-1" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常信息都往外抛  </span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">8899</span>;  </span><br><span class="line">      <span class="comment">//定义一个ServerSocket监听在端口8899上  </span></span><br><span class="line">      ServerSocket server = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">      <span class="comment">//server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span></span><br><span class="line">      Socket socket = server.accept();  </span><br><span class="line">      <span class="comment">//跟客户端建立好连接之后，我们就可以获取socket的InputStream，并从中读取客户端发过来的信息了。  </span></span><br><span class="line">      Reader reader = <span class="keyword">new</span> InputStreamReader(socket.getInputStream());  </span><br><span class="line">      <span class="keyword">char</span> chars[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];  </span><br><span class="line">      <span class="keyword">int</span> len;  </span><br><span class="line">      StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">      <span class="keyword">while</span> ((len=reader.read(chars)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">         sb.append(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(<span class="string">"from client: "</span> + sb);  </span><br><span class="line">      <span class="comment">//读完后写一句  </span></span><br><span class="line">      Writer writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">      writer.write(<span class="string">"Hello Client."</span>);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      writer.close();  </span><br><span class="line">      reader.close();  </span><br><span class="line">      socket.close();  </span><br><span class="line">      server.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中首先我们从输入流中读取客户端发送过来的数据，接下来我们再往输出流里面写入数据给客户端，接下来关闭对应的资源文件。而实际上上述代码可能并不会按照我们预先设想的方式运行，因为从输入流中读取数据是一个阻塞式操作，在上述的while循环中当读到数据的时候就会执行循环体，否则就会阻塞，这样后面的写操作就永远都执行不了了。除非客户端对应的Socket关闭了阻塞才会停止，while循环也会跳出。针对这种可能永远无法执行下去的情况的解决方法是while循环需要在里面有条件的跳出来，纵观上述代码，在不断变化的也只有取到的长度len和读到的数据了，len已经是不能用的了，唯一能用的就是读到的数据了。针对这种情况，通常我们都会约定一个结束标记，当客户端发送过来的数据包含某个结束标记时就说明当前的数据已经发送完毕了，这个时候我们就可以进行循环的跳出了。那么改进后的代码会是这个样子：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Server &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws IOException &#123;  </span><br><span class="line">      //为了简单起见，所有的异常信息都往外抛  </span><br><span class="line">      int port = 8899;  </span><br><span class="line">      //定义一个ServerSocket监听在端口8899上  </span><br><span class="line">      ServerSocket server = new ServerSocket(port);  </span><br><span class="line">      //server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span><br><span class="line">      Socket socket = server.accept();  </span><br><span class="line">      //跟客户端建立好连接之后，我们就可以获取socket的InputStream，并从中读取客户端发过来的信息了。  </span><br><span class="line">      Reader reader = new InputStreamReader(socket.getInputStream());  </span><br><span class="line">      char chars[] = new char[64];  </span><br><span class="line">      int len;  </span><br><span class="line">      StringBuilder sb = new StringBuilder();  </span><br><span class="line">      String temp;  </span><br><span class="line">      int index;  </span><br><span class="line">      while ((len=reader.read(chars)) != -1) &#123;  </span><br><span class="line">         temp = new String(chars, 0, len);  </span><br><span class="line">         if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;//遇到eof时就结束接收  </span><br><span class="line">            sb.append(temp.substring(0, index));  </span><br><span class="line">            break;  </span><br><span class="line">         &#125;  </span><br><span class="line">         sb.append(temp);  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(&quot;from client: &quot; + sb);  </span><br><span class="line">      //读完后写一句  </span><br><span class="line">      Writer writer = new OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Client.&quot;);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      writer.close();  </span><br><span class="line">      reader.close();  </span><br><span class="line">      socket.close();  </span><br><span class="line">      server.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，当服务端读取到客户端发送的结束标记，即“eof”时就会结束数据的接收，终止循环，这样后续的代码又可以继续进行了。</p></blockquote><h3 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">      //为了简单起见，所有的异常都直接往外抛  </span><br><span class="line">     String host = &quot;127.0.0.1&quot;;  //要连接的服务端IP地址  </span><br><span class="line">     int port = 8899;   //要连接的服务端对应的监听端口  </span><br><span class="line">     //与服务端建立连接  </span><br><span class="line">     Socket client = new Socket(host, port);  </span><br><span class="line">      //建立连接后就可以往服务端写数据了  </span><br><span class="line">     Writer writer = new OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Server.&quot;);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      //写完以后进行读操作  </span><br><span class="line">     Reader reader = new InputStreamReader(client.getInputStream());  </span><br><span class="line">      char chars[] = new char[64];  </span><br><span class="line">      int len;  </span><br><span class="line">      StringBuffer sb = new StringBuffer();  </span><br><span class="line">      while ((len=reader.read(chars)) != -1) &#123;  </span><br><span class="line">         sb.append(new String(chars, 0, len));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(&quot;from server: &quot; + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      reader.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中我们先是给服务端发送了一段数据，之后读取服务端返回来的数据，跟之前的服务端一样在读的过程中有可能导致程序一直挂在那里，永远跳不出while循环。这段代码配合服务端的第一段代码就正好让我们分析服务端永远在那里接收数据，永远跳不出while循环，也就没有之后的服务端返回数据给客户端，客户端也就不可能接收到服务端返回的数据。解决方法如服务端第二段代码所示，在客户端发送数据完毕后，往输出流里面写入结束标记告诉服务端数据已经发送完毕了，同样服务端返回数据完毕后也发一个标记告诉客户端。那么修改后的客户端代码就应该是这个样子：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">      //为了简单起见，所有的异常都直接往外抛  </span><br><span class="line">     String host = &quot;127.0.0.1&quot;;  //要连接的服务端IP地址  </span><br><span class="line">     int port = 8899;   //要连接的服务端对应的监听端口  </span><br><span class="line">     //与服务端建立连接  </span><br><span class="line">     Socket client = new Socket(host, port);  </span><br><span class="line">      //建立连接后就可以往服务端写数据了  </span><br><span class="line">     Writer writer = new OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Server.&quot;);  </span><br><span class="line">      writer.write(&quot;eof&quot;);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      //写完以后进行读操作  </span><br><span class="line">     Reader reader = new InputStreamReader(client.getInputStream());  </span><br><span class="line">      char chars[] = new char[64];  </span><br><span class="line">      int len;  </span><br><span class="line">      StringBuffer sb = new StringBuffer();  </span><br><span class="line">      String temp;  </span><br><span class="line">      int index;  </span><br><span class="line">      while ((len=reader.read(chars)) != -1) &#123;  </span><br><span class="line">         temp = new String(chars, 0, len);  </span><br><span class="line">         if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;  </span><br><span class="line">            sb.append(temp.substring(0, index));  </span><br><span class="line">            break;  </span><br><span class="line">         &#125;  </span><br><span class="line">         sb.append(new String(chars, 0, len));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(&quot;from server: &quot; + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      reader.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们日常使用的比较多的都是这种客户端发送数据给服务端，服务端接收数据后再返回相应的结果给客户端这种形式。只是客户端和服务端之间不再是这种一对一的关系，而是下面要讲到的多个客户端对应同一个服务端的情况。</p></blockquote><h2 id="3-多个客户端连接同一个服务端"><a href="#3-多个客户端连接同一个服务端" class="headerlink" title="3. 多个客户端连接同一个服务端"></a>3. 多个客户端连接同一个服务端</h2><blockquote><p>像前面讲的两个例子都是服务端接收一个客户端的请求之后就结束了，不能再接收其他客户端的请求了，这往往是不能满足我们的要求的。通常我们会这样做：</p></blockquote><h3 id="服务端代码-2"><a href="#服务端代码-2" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常信息都往外抛  </span></span><br><span class="line">     <span class="keyword">int</span> port = <span class="number">8899</span>;  </span><br><span class="line">      <span class="comment">//定义一个ServerSocket监听在端口8899上  </span></span><br><span class="line">     ServerSocket server = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">         <span class="comment">//server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span></span><br><span class="line">       Socket socket = server.accept();  </span><br><span class="line">         <span class="comment">//跟客户端建立好连接之后，我们就可以获取socket的InputStream，并从中读取客户端发过来的信息了。  </span></span><br><span class="line">       Reader reader = <span class="keyword">new</span> InputStreamReader(socket.getInputStream());  </span><br><span class="line">         <span class="keyword">char</span> chars[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];  </span><br><span class="line">         <span class="keyword">int</span> len;  </span><br><span class="line">         StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">         String temp;  </span><br><span class="line">         <span class="keyword">int</span> index;  </span><br><span class="line">         <span class="keyword">while</span> ((len=reader.read(chars)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">            temp = <span class="keyword">new</span> String(chars, <span class="number">0</span>, len);  </span><br><span class="line">            <span class="keyword">if</span> ((index = temp.indexOf(<span class="string">"eof"</span>)) != -<span class="number">1</span>) &#123;<span class="comment">//遇到eof时就结束接收  </span></span><br><span class="line">                sb.append(temp.substring(<span class="number">0</span>, index));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">         System.out.println(<span class="string">"from client: "</span> + sb);  </span><br><span class="line">         <span class="comment">//读完后写一句  </span></span><br><span class="line">       Writer writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">         writer.write(<span class="string">"Hello Client."</span>);  </span><br><span class="line">         writer.flush();  </span><br><span class="line">         writer.close();  </span><br><span class="line">         reader.close();  </span><br><span class="line">         socket.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面代码中我们用了一个死循环，在循环体里面ServerSocket调用其accept方法试图接收来自客户端的连接请求。当没有接收到请求的时候，程序会在这里阻塞直到接收到来自客户端的连接请求，之后会跟当前建立好连接的客户端进行通信，完了后会接着执行循环体再次尝试接收新的连接请求。这样我们的ServerSocket就能接收来自所有客户端的连接请求了，并且与它们进行通信了。这就实现了一个简单的一个服务端与多个客户端进行通信的模式。</p></blockquote><blockquote><p>上述例子中虽然实现了一个服务端跟多个客户端进行通信，但是还存在一个问题。在上述例子中，我们的服务端处理客户端的连接请求是同步进行的，每次接收到来自客户端的连接请求后，都要先跟当前的客户端通信完之后才能再处理下一个连接请求。这在并发比较多的情况下会严重影响程序的性能，为此，我们可以把它改为如下这种异步处理与客户端通信的方式：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Server &#123;  </span><br><span class="line">     </span><br><span class="line">   public static void main(String args[]) throws IOException &#123;  </span><br><span class="line">      //为了简单起见，所有的异常信息都往外抛  </span><br><span class="line">     int port = 8899;  </span><br><span class="line">      //定义一个ServerSocket监听在端口8899上  </span><br><span class="line">     ServerSocket server = new ServerSocket(port);  </span><br><span class="line">      while (true) &#123;  </span><br><span class="line">         //server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span><br><span class="line">         Socket socket = server.accept();  </span><br><span class="line">         //每接收到一个Socket就建立一个新的线程来处理它  </span><br><span class="line">         new Thread(new Task(socket)).start();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   /** </span><br><span class="line">    * 用来处理Socket请求的 </span><br><span class="line">   */  </span><br><span class="line">   static class Task implements Runnable &#123;  </span><br><span class="line">   </span><br><span class="line">      private Socket socket;  </span><br><span class="line">        </span><br><span class="line">      public Task(Socket socket) &#123;  </span><br><span class="line">         this.socket = socket;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      public void run() &#123;  </span><br><span class="line">  </span><br><span class="line">         try &#123;  </span><br><span class="line">  </span><br><span class="line">            handleSocket();  </span><br><span class="line">         &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      /** </span><br><span class="line">       * 跟客户端Socket进行通信 </span><br><span class="line">       * @throws Exception </span><br><span class="line">       */  </span><br><span class="line">      private void handleSocket() throws Exception &#123;  </span><br><span class="line">         Reader reader = new InputStreamReader(socket.getInputStream());  </span><br><span class="line">         char chars[] = new char[64];  </span><br><span class="line">         int len;  </span><br><span class="line">         StringBuilder sb = new StringBuilder();  </span><br><span class="line">         String temp;  </span><br><span class="line">         int index;  </span><br><span class="line">         while ((len=reader.read(chars)) != -1) &#123;  </span><br><span class="line">            temp = new String(chars, 0, len);  </span><br><span class="line">            if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;//遇到eof时就结束接收  </span><br><span class="line">             sb.append(temp.substring(0, index));  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">         System.out.println(&quot;from client: &quot; + sb);  </span><br><span class="line">         //读完后写一句  </span><br><span class="line">       Writer writer = new OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">         writer.write(&quot;Hello Client.&quot;);  </span><br><span class="line">         writer.flush();  </span><br><span class="line">         writer.close();  </span><br><span class="line">         reader.close();  </span><br><span class="line">         socket.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面代码中，每次ServerSocket接收到一个新的Socket连接请求后都会新起一个线程来跟当前Socket进行通信，这样就达到了异步处理与客户端Socket进行通信的情况。</p></blockquote><blockquote><p>在从Socket的InputStream中接收数据时，像上面那样一点点的读就太复杂了，有时候我们就会换成使用BufferedReader来一次读一行，如：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Server &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws IOException &#123;  </span><br><span class="line">      //为了简单起见，所有的异常信息都往外抛  </span><br><span class="line">     int port = 8899;  </span><br><span class="line">      //定义一个ServerSocket监听在端口8899上  </span><br><span class="line">     ServerSocket server = new ServerSocket(port);  </span><br><span class="line">      while (true) &#123;  </span><br><span class="line">         //server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span><br><span class="line">         Socket socket = server.accept();  </span><br><span class="line">         //每接收到一个Socket就建立一个新的线程来处理它  </span><br><span class="line">         new Thread(new Task(socket)).start();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   /** </span><br><span class="line">    * 用来处理Socket请求的 </span><br><span class="line">   */  </span><br><span class="line">   static class Task implements Runnable &#123;  </span><br><span class="line">   </span><br><span class="line">      private Socket socket;  </span><br><span class="line">        </span><br><span class="line">      public Task(Socket socket) &#123;  </span><br><span class="line">         this.socket = socket;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      public void run() &#123;  </span><br><span class="line">         try &#123;  </span><br><span class="line">            handleSocket();  </span><br><span class="line">         &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      /** </span><br><span class="line">       * 跟客户端Socket进行通信 </span><br><span class="line">      * @throws Exception </span><br><span class="line">       */  </span><br><span class="line">      private void handleSocket() throws Exception &#123;  </span><br><span class="line">         BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));  </span><br><span class="line">         StringBuilder sb = new StringBuilder();  </span><br><span class="line">         String temp;  </span><br><span class="line">         int index;  </span><br><span class="line">         while ((temp=br.readLine()) != null) &#123;  </span><br><span class="line">            System.out.println(temp);  </span><br><span class="line">            if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;//遇到eof时就结束接收  </span><br><span class="line">             sb.append(temp.substring(0, index));  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">         System.out.println(&quot;from client: &quot; + sb);  </span><br><span class="line">         //读完后写一句  </span><br><span class="line">       Writer writer = new OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">         writer.write(&quot;Hello Client.&quot;);  </span><br><span class="line">         writer.write(&quot;eof\n&quot;);  </span><br><span class="line">         writer.flush();  </span><br><span class="line">         writer.close();  </span><br><span class="line">         br.close();  </span><br><span class="line">         socket.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个时候需要注意的是，BufferedReader的readLine方法是一次读一行的，这个方法是阻塞的，直到它读到了一行数据为止程序才会继续往下执行，那么readLine什么时候才会读到一行呢？直到程序遇到了换行符或者是对应流的结束符readLine方法才会认为读到了一行，才会结束其阻塞，让程序继续往下执行。所以我们在使用BufferedReader的readLine读取数据的时候一定要记得在对应的输出流里面一定要写入换行符（流结束之后会自动标记为结束，readLine可以识别），写入换行符之后一定记得如果输出流不是马上关闭的情况下记得flush一下，这样数据才会真正的从缓冲区里面写入。对应上面的代码我们的客户端程序应该这样写：</p></blockquote><h3 id="客户端代码-2"><a href="#客户端代码-2" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">  </span><br><span class="line">   public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">      //为了简单起见，所有的异常都直接往外抛  </span><br><span class="line">     String host = &quot;127.0.0.1&quot;;  //要连接的服务端IP地址  </span><br><span class="line">     int port = 8899;   //要连接的服务端对应的监听端口  </span><br><span class="line">     //与服务端建立连接  </span><br><span class="line">     Socket client = new Socket(host, port);  </span><br><span class="line">      //建立连接后就可以往服务端写数据了  </span><br><span class="line">     Writer writer = new OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Server.&quot;);  </span><br><span class="line">      writer.write(&quot;eof\n&quot;);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      //写完以后进行读操作  </span><br><span class="line">     BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));  </span><br><span class="line">      StringBuffer sb = new StringBuffer();  </span><br><span class="line">      String temp;  </span><br><span class="line">      int index;  </span><br><span class="line">      while ((temp=br.readLine()) != null) &#123;  </span><br><span class="line">         if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;  </span><br><span class="line">            sb.append(temp.substring(0, index));  </span><br><span class="line">            break;  </span><br><span class="line">         &#125;  </span><br><span class="line">         sb.append(temp);  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(&quot;from server: &quot; + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      br.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、设置超时时间"><a href="#三、设置超时时间" class="headerlink" title="三、设置超时时间"></a>三、设置超时时间</h1><blockquote><p>假设有这样一种需求，我们的客户端需要通过Socket从服务端获取到XX信息，然后给用户展示在页面上。我们知道Socket在读数据的时候是阻塞式的，如果没有读到数据程序会一直阻塞在那里。在同步请求的时候我们肯定是不能允许这样的情况发生的，这就需要我们在请求达到一定的时间后控制阻塞的中断，让程序得以继续运行。Socket为我们提供了一个setSoTimeout()方法来设置接收数据的超时时间，单位是毫秒。当设置的超时时间大于0，并且超过了这一时间Socket还没有接收到返回的数据的话，Socket就会抛出一个SocketTimeoutException。</p></blockquote><blockquote><p>假设我们需要控制我们的客户端在开始读取数据10秒后还没有读到数据就中断阻塞的话我们可以这样做：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常都直接往外抛  </span></span><br><span class="line">     String host = <span class="string">"127.0.0.1"</span>;  <span class="comment">//要连接的服务端IP地址  </span></span><br><span class="line">     <span class="keyword">int</span> port = <span class="number">8899</span>;   <span class="comment">//要连接的服务端对应的监听端口  </span></span><br><span class="line">     <span class="comment">//与服务端建立连接  </span></span><br><span class="line">     Socket client = <span class="keyword">new</span> Socket(host, port);  </span><br><span class="line">      <span class="comment">//建立连接后就可以往服务端写数据了  </span></span><br><span class="line">     Writer writer = <span class="keyword">new</span> OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(<span class="string">"Hello Server."</span>);  </span><br><span class="line">      writer.write(<span class="string">"eof\n"</span>);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      <span class="comment">//写完以后进行读操作  </span></span><br><span class="line">     BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));  </span><br><span class="line">      <span class="comment">//设置超时间为10秒  </span></span><br><span class="line">     client.setSoTimeout(<span class="number">10</span>*<span class="number">1000</span>);  </span><br><span class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer();  </span><br><span class="line">      String temp;  </span><br><span class="line">      <span class="keyword">int</span> index;  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="keyword">while</span> ((temp=br.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((index = temp.indexOf(<span class="string">"eof"</span>)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                sb.append(temp.substring(<span class="number">0</span>, index));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;  </span><br><span class="line">         System.out.println(<span class="string">"数据读取超时。"</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(<span class="string">"from server: "</span> + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      br.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、接收数据乱码"><a href="#四、接收数据乱码" class="headerlink" title="四、接收数据乱码"></a>四、接收数据乱码</h1><blockquote><p>对于这种服务端或客户端接收中文乱码的情况通常是因为数据发送时使用的编码跟接收时候使用的编码不一致。比如有下面这样一段服务端代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常信息都往外抛  </span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">8899</span>;  </span><br><span class="line">      <span class="comment">//定义一个ServerSocket监听在端口8899上  </span></span><br><span class="line">      ServerSocket server = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">         <span class="comment">//server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span></span><br><span class="line">         Socket socket = server.accept();  </span><br><span class="line">         <span class="comment">//每接收到一个Socket就建立一个新的线程来处理它  </span></span><br><span class="line">         <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(socket)).start();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 用来处理Socket请求的 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> Socket socket;  </span><br><span class="line">        </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Socket socket)</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">this</span>.socket = socket;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">try</span> &#123;  </span><br><span class="line">            handleSocket();  </span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 跟客户端Socket进行通信 </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSocket</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">         BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream(), <span class="string">"GBK"</span>));  </span><br><span class="line">         StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">         String temp;  </span><br><span class="line">         <span class="keyword">int</span> index;  </span><br><span class="line">         <span class="keyword">while</span> ((temp=br.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            System.out.println(temp);  </span><br><span class="line">            <span class="keyword">if</span> ((index = temp.indexOf(<span class="string">"eof"</span>)) != -<span class="number">1</span>) &#123;<span class="comment">//遇到eof时就结束接收  </span></span><br><span class="line">             sb.append(temp.substring(<span class="number">0</span>, index));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">         System.out.println(<span class="string">"客户端: "</span> + sb);  </span><br><span class="line">         <span class="comment">//读完后写一句  </span></span><br><span class="line">       Writer writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream(), <span class="string">"UTF-8"</span>);  </span><br><span class="line">         writer.write(<span class="string">"你好，客户端。"</span>);  </span><br><span class="line">         writer.write(<span class="string">"eof\n"</span>);  </span><br><span class="line">         writer.flush();  </span><br><span class="line">         writer.close();  </span><br><span class="line">         br.close();  </span><br><span class="line">         socket.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里用来测试我就弄的混乱了一点。在上面服务端代码中我们在定义输入流的时候明确定义了使用GBK编码来读取数据，而在定义输出流的时候明确指定了将使用UTF-8编码来发送数据。如果客户端上送数据的时候不以GBK编码来发送的话服务端接收的数据就很有可能会乱码；同样如果客户端接收数据的时候不以服务端发送数据的编码，即UTF-8编码来接收数据的话也极有可能会出现数据乱码的情况。所以，对于上述服务端代码，为使我们的程序能够读取对方发送过来的数据，而不出现乱码情况，我们的客户端应该是这样的：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常都直接往外抛  </span></span><br><span class="line">     String host = <span class="string">"127.0.0.1"</span>;  <span class="comment">//要连接的服务端IP地址  </span></span><br><span class="line">     <span class="keyword">int</span> port = <span class="number">8899</span>;   <span class="comment">//要连接的服务端对应的监听端口  </span></span><br><span class="line">     <span class="comment">//与服务端建立连接  </span></span><br><span class="line">     Socket client = <span class="keyword">new</span> Socket(host, port);  </span><br><span class="line">      <span class="comment">//建立连接后就可以往服务端写数据了  </span></span><br><span class="line">     Writer writer = <span class="keyword">new</span> OutputStreamWriter(client.getOutputStream(), <span class="string">"GBK"</span>);  </span><br><span class="line">      writer.write(<span class="string">"你好，服务端。"</span>);  </span><br><span class="line">      writer.write(<span class="string">"eof\n"</span>);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      <span class="comment">//写完以后进行读操作  </span></span><br><span class="line">     BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream(), <span class="string">"UTF-8"</span>));  </span><br><span class="line">      <span class="comment">//设置超时间为10秒  </span></span><br><span class="line">     client.setSoTimeout(<span class="number">10</span>*<span class="number">1000</span>);  </span><br><span class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer();  </span><br><span class="line">      String temp;  </span><br><span class="line">      <span class="keyword">int</span> index;  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="keyword">while</span> ((temp=br.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((index = temp.indexOf(<span class="string">"eof"</span>)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                sb.append(temp.substring(<span class="number">0</span>, index));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;  </span><br><span class="line">         System.out.println(<span class="string">"数据读取超时。"</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(<span class="string">"服务端: "</span> + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      br.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、作者声明"><a href="#五、作者声明" class="headerlink" title="五、作者声明"></a>五、作者声明</h1><p>原文链接：<a href="http://elim.iteye.com/blog/1979837" target="_blank" rel="noopener">http://elim.iteye.com/blog/1979837</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Java-Socket简介&quot;&gt;&lt;a href=&quot;#一、Java-Socket简介&quot; class=&quot;headerlink&quot; title=&quot;一、Java Socket简介&quot;&gt;&lt;/a&gt;一、Java Socket简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;对于Jav
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
