<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hongwei&#39;s Diary</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiaohongwei.github.io/"/>
  <updated>2019-05-09T00:00:22.669Z</updated>
  <id>https://jiaohongwei.github.io/</id>
  
  <author>
    <name>伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里云ECS CentOS 7.2 安装Redis服务</title>
    <link href="https://jiaohongwei.github.io/2019/05/09/%E9%98%BF%E9%87%8C%E4%BA%91ECS-CentOS-7-2-%E5%AE%89%E8%A3%85Redis%E6%9C%8D%E5%8A%A1/"/>
    <id>https://jiaohongwei.github.io/2019/05/09/阿里云ECS-CentOS-7-2-安装Redis服务/</id>
    <published>2019-05-08T23:54:40.000Z</published>
    <updated>2019-05-09T00:00:22.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><ul><li>查看系统版本 <code>lsb_release -a</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze1rex9zp7ain1q5h54Z ~]# lsb_release -a</span><br><span class="line">LSB Version::core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID:CentOS</span><br><span class="line">Description:CentOS Linux release 7.2.1511 (Core) </span><br><span class="line">Release:7.2.1511</span><br><span class="line">Codename:Core</span><br></pre></td></tr></table></figure><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="1、设置Redis的仓库地址"><a href="#1、设置Redis的仓库地址" class="headerlink" title="1、设置Redis的仓库地址"></a>1、设置Redis的仓库地址</h3><p><code>yum install epel-release</code></p><h3 id="2、安装redis"><a href="#2、安装redis" class="headerlink" title="2、安装redis"></a>2、安装redis</h3><p><code>yum install redis</code></p><ul><li><code>whereis redis</code>  查看配置文件在哪</li><li>服务器和客户端在 <code>/usr/bin/redis-server redis-cli</code></li></ul><h3 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h3><p><code>vim /etc/redis.conf</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#监听所有的IP地址（61行）</span><br><span class="line">bind 127.0.0.1 注释掉为 #bind 127.0.0.1</span><br><span class="line">#设置为守护进程（128行）</span><br><span class="line">daemonize no 改为 daemonize yes </span><br><span class="line">#设置密码（480行）</span><br><span class="line">requirepass xxx</span><br><span class="line">#最大物理内存设置（537行）在真实环境必须部署，否则物理内存会被耗尽。一般配置200mb/500mb/1gb/2gb。配置了最大内存 maxmemory 之后记得配置过期删除策略</span><br><span class="line">maxmemory 200mb</span><br><span class="line">#过期删除策略（560行）</span><br><span class="line">    # volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。 </span><br><span class="line">    # allkeys-lru -&gt; 根据LRU算法删除任何key。 </span><br><span class="line">    # volatile-random -&gt; 根据过期设置来随机删除key。 </span><br><span class="line">    # allkeys-&gt;random -&gt; 无差别随机删。 </span><br><span class="line">    # volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL） </span><br><span class="line">    # noeviction -&gt; 谁也不删，直接在写操作时返回错误。</span><br><span class="line">maxmemory-ploicy volatile-lru</span><br><span class="line"></span><br><span class="line">*找不到可以先拉到windows下查找定位</span><br></pre></td></tr></table></figure><h3 id="4、启动Redis"><a href="#4、启动Redis" class="headerlink" title="4、启动Redis"></a>4、启动Redis</h3><p><code>service redis start</code> </p><ul><li>或者指定配置文件启动 <br></li></ul><p><code>redis-server /usr/local/redis_cluster/7000/redis.conf</code></p><ul><li>如果需要设置开机自动启动</li></ul><p><code>chkconfig redis on</code></p><h3 id="5、查看状态"><a href="#5、查看状态" class="headerlink" title="5、查看状态"></a>5、查看状态</h3><ul><li><code>redis-server -v</code> 查看版本 </li><li><code>service redis status</code> 查看redis状态</li><li><code>service redis restart</code> redis 重新启动</li><li><code>service redis stop</code> 关闭redis服务</li></ul><h3 id="6、测试启动"><a href="#6、测试启动" class="headerlink" title="6、测试启动"></a>6、测试启动</h3><ul><li><code>redis-cli -h 127.0.0.1 -p 6379 -a password</code></li><li>如出现<code>(error) NOAUTH Authentication required.</code> 错误，如下<code>auth password</code>指定密码</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth password</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="7、Redis配置"><a href="#7、Redis配置" class="headerlink" title="7、Redis配置"></a>7、Redis配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7.1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class="line"></span><br><span class="line">    daemonize no</span><br><span class="line"></span><br><span class="line">7.2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class="line"></span><br><span class="line">    pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line">7.3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</span><br><span class="line"></span><br><span class="line">    port 6379</span><br><span class="line"></span><br><span class="line">7.7. 绑定的主机地址</span><br><span class="line"></span><br><span class="line">    bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">7.5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line"></span><br><span class="line">    timeout 300</span><br><span class="line"></span><br><span class="line">7.6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class="line"></span><br><span class="line">    loglevel verbose</span><br><span class="line"></span><br><span class="line">7.7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class="line"></span><br><span class="line">    logfile stdout</span><br><span class="line"></span><br><span class="line">7.8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class="line"></span><br><span class="line">    databases 16</span><br><span class="line"></span><br><span class="line">7.9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line"></span><br><span class="line">    save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line">    Redis默认配置文件中提供了三个条件：</span><br><span class="line"></span><br><span class="line">    save 900 1</span><br><span class="line"></span><br><span class="line">    save 300 10</span><br><span class="line"></span><br><span class="line">    save 60 10000</span><br><span class="line"></span><br><span class="line">    分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">7.10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line"></span><br><span class="line">    rdbcompression yes</span><br><span class="line"></span><br><span class="line">7.11. 指定本地数据库文件名，默认值为dump.rdb</span><br><span class="line"></span><br><span class="line">    dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">7.12. 指定本地数据库存放目录</span><br><span class="line"></span><br><span class="line">    dir ./</span><br><span class="line"></span><br><span class="line">7.13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class="line"></span><br><span class="line">    slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line">7.17. 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class="line"></span><br><span class="line">    masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">7.15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class="line"></span><br><span class="line">    requirepass foobared</span><br><span class="line"></span><br><span class="line">7.16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。</span><br><span class="line">    当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class="line"></span><br><span class="line">    maxclients 128</span><br><span class="line"></span><br><span class="line">7.17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，</span><br><span class="line">    当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class="line"></span><br><span class="line">    maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">7.18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，</span><br><span class="line">    如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class="line"></span><br><span class="line">    appendonly no</span><br><span class="line"></span><br><span class="line">7.19. 指定更新日志文件名，默认为appendonly.aof</span><br><span class="line"></span><br><span class="line">     appendfilename appendonly.aof</span><br><span class="line"></span><br><span class="line">7.20. 指定更新日志条件，共有3个可选值： </span><br><span class="line">    no：表示等操作系统进行数据缓存同步到磁盘（快） </span><br><span class="line">    always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span><br><span class="line">    everysec：表示每秒同步一次（折衷，默认值）</span><br><span class="line"></span><br><span class="line">    appendfsync everysec</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">7.21. 指定是否启用虚拟内存机制，默认值为no，</span><br><span class="line">   简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</span><br><span class="line"></span><br><span class="line">     vm-enabled no</span><br><span class="line"></span><br><span class="line">7.22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class="line"></span><br><span class="line">     vm-swap-file /tmp/redis.swap</span><br><span class="line"></span><br><span class="line">7.23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),</span><br><span class="line">    也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class="line"></span><br><span class="line">     vm-max-memory 0</span><br><span class="line"></span><br><span class="line">7.24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，</span><br><span class="line">    作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class="line"></span><br><span class="line">     vm-page-size 32</span><br><span class="line"></span><br><span class="line">7.25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class="line"></span><br><span class="line">     vm-pages 134217728</span><br><span class="line"></span><br><span class="line">7.26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class="line"></span><br><span class="line">     vm-max-threads 4</span><br><span class="line"></span><br><span class="line">7.27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class="line"></span><br><span class="line">    glueoutputbuf yes</span><br><span class="line"></span><br><span class="line">7.28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class="line"></span><br><span class="line">    hash-max-zipmap-entries 64</span><br><span class="line"></span><br><span class="line">    hash-max-zipmap-value 512</span><br><span class="line"></span><br><span class="line">7.29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class="line"></span><br><span class="line">    activerehashing yes</span><br><span class="line"></span><br><span class="line">7.30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class="line"></span><br><span class="line">    include /path/to/local.conf</span><br></pre></td></tr></table></figure><h3 id="8、防火墙配置"><a href="#8、防火墙配置" class="headerlink" title="8、防火墙配置"></a>8、防火墙配置</h3><ul><li>使用redis desktop manager连接redis，如果连接不上需要将6379端口加到防火墙的开放白名单中，使用如下命令(centos 7.2):</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=6379/tcp</span><br><span class="line">firewall-cmd --reload //生效</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、环境&quot;&gt;&lt;a href=&quot;#一、环境&quot; class=&quot;headerlink&quot; title=&quot;一、环境&quot;&gt;&lt;/a&gt;一、环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查看系统版本 &lt;code&gt;lsb_release -a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure cl
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://jiaohongwei.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://jiaohongwei.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 基本操作</title>
    <link href="https://jiaohongwei.github.io/2019/04/27/Kafka-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://jiaohongwei.github.io/2019/04/27/Kafka-基本操作/</id>
    <published>2019-04-27T10:00:33.000Z</published>
    <updated>2019-04-27T10:05:17.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka-基本操作"><a href="#Kafka-基本操作" class="headerlink" title="Kafka 基本操作"></a>Kafka 基本操作</h2><h3 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h3><ol><li>zookeeper: </li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>kafka: </li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.2.0/kafka_2.11-2.2.0.tgz</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压:"></a>解压:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.14.tar.gz</span><br><span class="line">tar -zxvf kafka_2.11-2.2.0.tgz</span><br></pre></td></tr></table></figure><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><h4 id="1-zookeeper"><a href="#1-zookeeper" class="headerlink" title="1. zookeeper"></a>1. zookeeper</h4><p>配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper-3.4.14/config</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh  start</span><br></pre></td></tr></table></figure><p>连接测试，zookeeper 默认启动端口2181</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure><h4 id="2-kafka"><a href="#2-kafka" class="headerlink" title="2.kafka"></a>2.kafka</h4><p>创建日志目录 替换临时日志目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../kafka_2.11-2.2.0/</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim config/server.properties</span><br></pre></td></tr></table></figure><p>修改配置文件中21、31、36和60行如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://:9092</span><br><span class="line">advertised.listeners=PLAINTEXT://127.0.0.1:9092</span><br><span class="line">log.dirs=/opt/soft/kafka_2.11-2.2.0/logs</span><br></pre></td></tr></table></figure><p>后台启动kafka</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ./bin/kafka-server-start.sh config/server.properties 1&gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>创建topic</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --create --zookeeper 127.0.0.1:2181 --replication-factor 1 --partitions 1 --topic weibo</span><br></pre></td></tr></table></figure><ul><li>列出topic</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --list --zookeeper 127.0.0.1:2181</span><br></pre></td></tr></table></figure><ul><li>创建生产者 生产消息</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list 127.0.0.1:9092 --topic weibo</span><br></pre></td></tr></table></figure><ul><li>创建消费者 消费topic</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server  127.0.0.1:9092 --topic weibo</span><br></pre></td></tr></table></figure><ul><li>查看Topic消息</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --describe --zookeeper 127.0.0.1:2181 --topic weibo</span><br></pre></td></tr></table></figure><ul><li>删除topic消息</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --delete --zookeeper 127.0.0.1:2181 --topic weibo</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>可以开启两个窗口，一个用作生产者生产消息，一个用作消费者监听topic消费消息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafka-基本操作&quot;&gt;&lt;a href=&quot;#Kafka-基本操作&quot; class=&quot;headerlink&quot; title=&quot;Kafka 基本操作&quot;&gt;&lt;/a&gt;Kafka 基本操作&lt;/h2&gt;&lt;h3 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://jiaohongwei.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="消息队列" scheme="https://jiaohongwei.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.6 抓取微博m站数据</title>
    <link href="https://jiaohongwei.github.io/2019/03/07/Python-3-6-%E6%8A%93%E5%8F%96%E5%BE%AE%E5%8D%9Am%E7%AB%99%E6%95%B0%E6%8D%AE/"/>
    <id>https://jiaohongwei.github.io/2019/03/07/Python-3-6-抓取微博m站数据/</id>
    <published>2019-03-07T06:18:37.000Z</published>
    <updated>2019-05-13T13:46:46.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-3-6-抓取微博m站数据"><a href="#Python-3-6-抓取微博m站数据" class="headerlink" title="Python 3.6 抓取微博m站数据"></a>Python 3.6 抓取微博m站数据</h2><h3 id="2019-05-01-更新内容"><a href="#2019-05-01-更新内容" class="headerlink" title="2019.05.01 更新内容"></a>2019.05.01 更新内容</h3><ol><li>containerid 可以通过 <code>&quot;107603&quot; + user_id</code> 组装得到，无需请求个人信息获取；</li><li>优化多线程抓取，修复之前因<code>urllib.request</code>全局定义，导致代理无法正常切回本地IP；</li><li>优化分布式抓取策略，由每台机器顺序获取用户ID 再拼装URL抓取策略，修改为每台机器顺序获取URL进行抓取。防止由于某个微博账号微博动态过多导致负责本ID的机器长时间运行，而其他机器就要等待，浪费时间和资源。</li><li>加入IP代理池维护脚本，可以定时维护代理池中的有效代理IP，及时剔除无效IP。</li><li>加入Redis定时消费脚本，解决因抓取结果过大导致redis性能下降。</li><li>增加Redis连接池<code>ConnectionPool</code> ，解决因Redis链接端口数过多导致Redis拒绝服务错误。</li><li>调整Redis数据存储结构，采用list+set结合，存储UID+URL</li><li>单机https代理消费约100元/天，单机5个进程+代理每天能达到1000万条数据</li></ol><h3 id="本脚本截止20190501"><a href="#本脚本截止20190501" class="headerlink" title="本脚本截止20190501"></a>本脚本截止20190501</h3><ul><li>网址： <a href="https://m.weibo.cn/u/5463009082" target="_blank" rel="noopener">https://m.weibo.cn/u/5463009082</a> 新浪微博m站（智能手机网页端）<br> </li><li>api ： <a href="https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=5463009082&amp;containerid=1076035463009082" target="_blank" rel="noopener">https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=5463009082&amp;containerid=1076035463009082</a><br> </li><li>抓取： 根据用户userId抓取历史发布的微博信息<br> </li><li>方法： python请求api接口（非页面）<br> </li><li>反扒： 疯狂抓取10-20s，IP会被禁封1-3分钟 或者 抓取2分钟禁封10分钟<br> </li><li>备注： 无需登录+IP代理池<br> </li><li>环境： Windosw或Linux、Python 3.6、Mysql、Redis<br> </li></ul><table><thead><tr><th>类型</th><th>效果</th><th>代理花费</th></tr></thead><tbody><tr><td>单机版（多线程+多进程）</td><td>150万/天</td><td>0</td></tr><tr><td>单机版（多线程+多进程）+IP代理池</td><td>1000万/天</td><td>100元/天</td></tr><tr><td>分布式（多线程+多进程）+IP代理池</td><td>千万~亿级</td><td>100*机器数量/天</td></tr></tbody></table><h3 id="抓取流程"><a href="#抓取流程" class="headerlink" title="抓取流程"></a>抓取流程</h3><ol><li><p>启动<code>save_uid.py</code>脚本将准备好的微博用户ID，存入Redis中，保存两份；</p><ul><li><code>r.lpush(WEIBO_UID_LIST_KEY, uid)</code>  用于第一次遍历UID请求每个UID的总页数，然后生成每个UID的所有URL。</li><li><code>r.sadd(WEIBO_UID_SET_KEY, uid)</code>    用于第二次请求，随机获取一个未抓取完的UID，去Redis中取当前UID剩余的URL进行抓取，全部抓取完毕则移除此UID。</li></ul></li><li><p>启动<code>proxy_pool.py</code>脚本，初始化IP代理池（如果不使用代理，此步骤可略过）</p><ul><li><code>target_money</code> 用来获取你所购买的IP代理剩余金额的URL连接</li><li><code>target_ip</code>   请求代理IP获取有效的代理IP</li><li><code>targetUrl</code>   用来校验当前IP是否有效</li><li><code>WEIBO_PROXY_SET_KEY</code> 存储有效的代理IP</li><li><code>WEIBO_PROXY_418_SET_KEY</code> 存储已经出现418错误的IP，会循环利用，直到代理失效</li><li><code>WEIBO_ERROR_PROXY_SET_KEY</code> 存储已经使用过的IP（失效IP），用于后期校验</li></ul></li><li><p>启动<code>start_crawler.py</code>脚本，开启抓取任务</p><ul><li>首先会第一次请求遍历UID，生成所有的URL，然后所有的线程获取URL进行抓取</li><li>先会尝试使用本地IP进行抓取，本地IP出现418之后，尝试去IP代理池获取可使用的IP，继续抓取</li><li>使用代理IP抓取超过60s，停止代理抓取改为使用本地IP，循环进行</li><li>代理IP出现418，则先去尝试使用本地IP，如果本地418再继续更换代理</li><li>如果代理池没有可用IP，则休息30s，继续使用本地IP</li></ul></li><li><p>添加Linux定时脚本，定时处理Redis队列中的抓取结果。</p></li></ol><h3 id="关于代理IP"><a href="#关于代理IP" class="headerlink" title="关于代理IP"></a>关于代理IP</h3><ul><li>抓取微博的https连接，只能使用https代理，可选择市面上其他类型的代理商；</li><li>免费的代理ip也有尝试，不过效果不是很好</li></ul><h3 id="部署问题"><a href="#部署问题" class="headerlink" title="部署问题"></a>部署问题</h3><ul><li>需要一台主服务器（或者本机Windows电脑）来初始化运行 <code>save_uid.py</code> 和 <code>proxy_pool.py</code>脚本</li><li>在Redis所在的服务器进行<code>redis_consumer.py</code>脚本的运行部署</li><li><code>start_crawler.py</code> 可以集群部署到多台服务器，但要保证都能网络连通到Redis服务器</li><li><p>添加定时脚本<code>crontab -e</code> 内容 如下</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 */1 * * * nohup python /data/hw/redis_consume.py &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li><p><code>service cron restart</code> 重启cron定时服务</p></li><li>创建start.sh 开启多进程抓取  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 开始爬虫程序;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=5;i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup python /data/hw/start_crawler.py 1&gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"开启爬虫程序进程"</span>+<span class="variable">$i</span>  </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">sleep 5s</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"已开启以下进程"</span></span><br><span class="line">ps -ef|grep python</span><br></pre></td></tr></table></figure></li></ul><h3 id="20190501目录"><a href="#20190501目录" class="headerlink" title="20190501目录"></a>20190501目录</h3><ul><li>proxy_pool.py     #维护IP代理池</li><li>redis_consume.py  #redis定时消费</li><li>save_uid.py       #初始化uid</li><li>start.sh          #一键启动脚本</li><li>start_crawler.py  #开启抓取程序，可以集群部署</li></ul><h2 id="旧版本README"><a href="#旧版本README" class="headerlink" title="旧版本README"></a>旧版本README</h2><p><a href="https://github.com/JiaoHongwei/Crawler_weibo/blob/master/README_20190307.md" target="_blank" rel="noopener">README_20190307.md</a></p><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/JiaoHongwei/Crawler_weibo" target="_blank" rel="noopener">https://github.com/JiaoHongwei/Crawler_weibo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-3-6-抓取微博m站数据&quot;&gt;&lt;a href=&quot;#Python-3-6-抓取微博m站数据&quot; class=&quot;headerlink&quot; title=&quot;Python 3.6 抓取微博m站数据&quot;&gt;&lt;/a&gt;Python 3.6 抓取微博m站数据&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
    
      <category term="Python" scheme="https://jiaohongwei.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://jiaohongwei.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁原理和实现</title>
    <link href="https://jiaohongwei.github.io/2019/02/22/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://jiaohongwei.github.io/2019/02/22/分布式锁原理和实现/</id>
    <published>2019-02-22T15:54:55.000Z</published>
    <updated>2019-02-22T15:55:22.606Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手及四次挥手详解【转】</title>
    <link href="https://jiaohongwei.github.io/2019/02/19/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jiaohongwei.github.io/2019/02/19/TCP三次握手及四次挥手详解/</id>
    <published>2019-02-19T15:07:12.000Z</published>
    <updated>2019-02-19T16:03:30.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP的报头"><a href="#TCP的报头" class="headerlink" title="TCP的报头"></a>TCP的报头</h1><p><img src="/2019/02/19/TCP三次握手及四次挥手详解/20180524114307959.png" alt></p><ul><li>源端口号：表示发送端端口号，字段长为16位。</li><li>目标端口号：表示接收端口号，字段长为16位。</li><li><p>序列号：表示发送数据的位置，字段长为32位。每发送一次数据，就累加一次该数据字节数的大小。</p><blockquote><p>注意：序列号不会从0或1开始，而是在建立连接时由计算机生成的一个随机数作为其初始值，通过SYN包发送给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。</p></blockquote></li><li><p>序号的优点：</p><ol><li>保证报文按序到达。</li><li>保证可靠性。</li><li>保证效率。</li><li>精准的报告哪些报文已经收到，哪些需要重传。</li></ol></li><li><p>确认应答号：表示下一次应该收到的数据的序列号，字段长为32字节。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。</p></li><li>首部长度：该字段长度为4位，单位为4字节（32位）。TCP首部长度不包括选项的话，是20个字节，20/4=5，5的二进制序列：0101，报头长度也叫数据偏移，所以该字段可以设置为5，选项字段最大的是40字节，所以，TCP首部长度为最大为20+40=60字节，该字段可以设置的最大长度为60/4=15。</li><li>保留：该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，即使收到的包在该字段不为0，此包也不会丢弃。</li><li>控制位：字段长为6，每一位从左到右分别为：URG、ACK、PSH、RST、SYN、FIN。当对应的值为1，表示有具体含义。</li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>URG</td><td>紧急指针是否有效。为1，表示某一位需要被优先处理。</td></tr><tr><td>ACK</td><td>确认号是否有效，一般置为1。</td></tr><tr><td>PSH</td><td>提示接收端应用程序立即从TCP缓冲区把数据读走。</td></tr><tr><td>RST</td><td>对方要求重新建立连接，复位。</td></tr><tr><td>SYN</td><td>请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1.</td></tr><tr><td>FIN</td><td>希望断开连接。</td></tr></tbody></table><ul><li>窗口大小：接收缓冲区的大小，TCP不允许发送超过此处所示大小的数据。</li><li>校验和：发送端填充，CRC校验，接收校验不通过，则认为数据有问题。和UDP的区别是，UDP校验的是数据本身，TCP校验的不仅包含TCP首部，而且包含TCP数据部分。</li><li>紧急指针：只有在URG为1时有效，该字段为1表示本报文的段中的紧急数据的指针。</li><li>选项：用于提高TCP的传输性能。需要根据首部长度进行控制，其最大长度为40字节。</li></ul><p>我们在着重讲一下在三次握手和四次挥手中的用到序列号、确认号及标志位。</p><hr><h1 id="seq、ack、SYN、FIN概念"><a href="#seq、ack、SYN、FIN概念" class="headerlink" title="seq、ack、SYN、FIN概念"></a>seq、ack、SYN、FIN概念</h1><ol><li><p>序列号seq</p><blockquote><p>占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每一个报文段指派一个序号，序列号seq就是这个报文段中的第一个字节的数据编号。</p></blockquote></li><li><p>确认号ack</p><blockquote><p>占4个字节，期待收到对方下一个报文段的第一个数据字节的序号，序列号表示报文段携带数据的第一个字节的编号，而确认号指的是期望接受到下一个字节的编号，因此挡墙报文段最后一个字节的编号+1即是确认号。</p></blockquote></li><li><p>确认ACK</p><blockquote><p>占1个比特位，仅当ACK=1，确认号字段才有效。ACK=0，确认号无效。</p></blockquote></li><li><p>同步SYN</p><blockquote><p>连接建立时用于同步序号。当SYN=1，ACK=0表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使用SYN=1，ACK=1.因此，SYN=1表示这是一个连接请求，或连接接收报文，SYN这个标志位只有在TCP建立连接才会被置为1，握手完成后SYN标志位被置为0.</p></blockquote></li><li><p>终止FIN</p><blockquote><p>用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p></blockquote></li></ol><h1 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h1><p><img src="/2019/02/19/TCP三次握手及四次挥手详解/20180717202520531.png" alt></p><p>step1:第一次握手</p><blockquote><p>建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。</p></blockquote><p>step2:第二次握手</p><blockquote><p>服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。</p></blockquote><p>step3:第三次握手</p><blockquote><p>客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。</p></blockquote><p>未连接队列</p><blockquote><p>在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包(syn=j)开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包时，删除该条目，服务器进入ESTAB_LISHED状态。</p></blockquote><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="1-为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？"><a href="#1-为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？" class="headerlink" title="1.为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？"></a>1.为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？</h3><blockquote><p>我们来分析一种特殊情况，假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是两次握手，假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器认为连接已经建立，但在发送数据的过程中数据丢失，客户端认为连接没有建立，会进行重传。假设每次发送的数据一直在丢失，客户端一直SYN，服务器就会产生多个无效连接，占用资源，这个时候服务器可能会挂掉。这个现象就是我们听过的“SYN的洪水攻击”。</p></blockquote><blockquote><p>总结：第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。</p></blockquote><h1 id="四次挥手过程（关闭客户端到服务器的连接）"><a href="#四次挥手过程（关闭客户端到服务器的连接）" class="headerlink" title="四次挥手过程（关闭客户端到服务器的连接）"></a>四次挥手过程（关闭客户端到服务器的连接）</h1><p><img src="/2019/02/19/TCP三次握手及四次挥手详解/20180717204202563.png" alt></p><p>step1：第一次挥手</p><blockquote><p>首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。</p></blockquote><p>step2：第二次挥手</p><blockquote><p>服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。</p></blockquote><p>step3：第三次挥手</p><blockquote><p>关闭服务器到客户端的连接，发送一个FIN给客户端。</p></blockquote><p>step4：第四次挥手</p><blockquote><p>客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p></blockquote><blockquote><p>客户端发送FIN后，进入终止等待状态，服务器收到客户端连接释放报文段后，就立即给客户端发送确认，服务器就进入CLOSE_WAIT状态，此时TCP服务器进程就通知高层应用进程，因而从客户端到服务器的连接就释放了。此时是“半关闭状态”，即客户端不可以发送给服务器，服务器可以发送给客户端。</p></blockquote><blockquote><p>此时，如果服务器没有数据报发送给客户端，其应用程序就通知TCP释放连接，然后发送给客户端连接释放数据报，并等待确认。客户端发送确认后，进入TIME_WAIT状态，但是此时TCP连接还没有释放，然后经过等待计时器设置的2MSL后，才进入到CLOSED状态。</p></blockquote><h2 id="常见面试题-1"><a href="#常见面试题-1" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="2-为什么需要2MSL时间？"><a href="#2-为什么需要2MSL时间？" class="headerlink" title="2.为什么需要2MSL时间？"></a>2.为什么需要2MSL时间？</h3><p>首先，MSL即Maximum Segment Lifetime，就是最大报文生存时间，是任何报文在网络上的存在的最长时间，超过这个时间报文将被丢弃。《TCP/IP详解》中是这样描述的：MSL是任何报文段被丢弃前在网络内的最长时间。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒、1分钟、2分钟等。</p><blockquote><p>TCP的TIME_WAIT需要等待2MSL，当TCP的一端发起主动关闭，三次挥手完成后发送第四次挥手的ACK包后就进入这个状态，等待2MSL时间主要目的是：防止最后一个ACK包对方没有收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可以继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。</p></blockquote><h3 id="3-为什么是四次挥手，而不是三次或是五次、六次？"><a href="#3-为什么是四次挥手，而不是三次或是五次、六次？" class="headerlink" title="3.为什么是四次挥手，而不是三次或是五次、六次？"></a>3.为什么是四次挥手，而不是三次或是五次、六次？</h3><blockquote><p>双方关闭连接要经过双方都同意。所以，首先是客服端给服务器发送FIN，要求关闭连接，服务器收到后会发送一个ACK进行确认。服务器然后再发送一个FIN，客户端发送ACK确认，并进入TIME_WAIT状态。等待2MSL后自动关闭。</p></blockquote><p>总结：</p><blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。即最后一个确认报文可能丢失，服务器会超时重传，然后服务器发送FIN请求关闭连接，客户端发送ACK确认。一个来回是两个报文生命周期。</p></blockquote><blockquote><p>如果没有等待时间，发送完确认报文段就立即释放连接的话，服务器就无法重传，因此也就收不到确认，就无法按步骤进入CLOSED状态，即必须收到确认才能close。</p></blockquote><blockquote><p>防止已经失效的连接请求报文出现在连接中。经过2MSL，在这个连续持续的时间内，产生的所有报文段就可以都从网络消失。 </p></blockquote><h3 id="4-如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#4-如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="4.如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>4.如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><blockquote><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TCP的报头&quot;&gt;&lt;a href=&quot;#TCP的报头&quot; class=&quot;headerlink&quot; title=&quot;TCP的报头&quot;&gt;&lt;/a&gt;TCP的报头&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/02/19/TCP三次握手及四次挥手详解/20180524114307959
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
      <category term="TCP" scheme="https://jiaohongwei.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://jiaohongwei.github.io/2019/01/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://jiaohongwei.github.io/2019/01/10/冒泡排序/</id>
    <published>2019-01-10T06:10:28.000Z</published>
    <updated>2019-02-17T06:14:11.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍了手写冒泡排序的基础版和增强版代码（有道云笔记迁移）</p></blockquote><h1 id="一、基础版"><a href="#一、基础版" class="headerlink" title="一、基础版"></a>一、基础版</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基础版</span><br><span class="line"> */</span><br><span class="line">private static void bubbleSort(int[] arr) &#123;</span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                int tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第&quot; + i + &quot;步：&quot; + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、增强版"><a href="#二、增强版" class="headerlink" title="二、增强版"></a>二、增强版</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 增强版</span><br><span class="line"> */</span><br><span class="line">private static void bubbleSortPlus(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 设定一个标记，若为true，则表示此次循环没有进行交换，</span><br><span class="line">             也就是待排序已经有序，排序已经完成</span><br><span class="line">         */</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                int tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = tmp;</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第&quot; + i + &quot;步：&quot; + Arrays.toString(arr));</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍了手写冒泡排序的基础版和增强版代码（有道云笔记迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、基础版&quot;&gt;&lt;a href=&quot;#一、基础版&quot; class=&quot;headerlink&quot; title=&quot;一、基础版&quot;&gt;&lt;/a&gt;一、基础版&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://jiaohongwei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>双重锁单例模式笔记</title>
    <link href="https://jiaohongwei.github.io/2019/01/10/%E5%8F%8C%E9%87%8D%E9%94%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiaohongwei.github.io/2019/01/10/双重锁单例模式笔记/</id>
    <published>2019-01-10T05:53:43.000Z</published>
    <updated>2019-02-23T02:26:20.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍了双重锁的单例模式实现方式和部分问题解答（有道云笔记迁移）</p></blockquote><h1 id="一、代码实现"><a href="#一、代码实现" class="headerlink" title="一、代码实现"></a>一、代码实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Description 双重锁单例模式</span><br><span class="line"> * @Author hw</span><br><span class="line"> * @Date 2019/1/10 16:27</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class SingleTon &#123;</span><br><span class="line">     private static volatile SingleTon singleTon;</span><br><span class="line">     private SingleTon() &#123;&#125;</span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">        if (singleTon == null) &#123;</span><br><span class="line">            synchronized (SingleTon.class) &#123;</span><br><span class="line">                if (singleTon == null) &#123;</span><br><span class="line">                    singleTon = new SingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译后的字节码指令</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10: monitorenter</span><br><span class="line">11: getstatic     #2                  // Field singleTon:LSingleTon;</span><br><span class="line">14: ifnonnull     27</span><br><span class="line">17: new           #3                  // class SingleTon</span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic     #2                  // Field singleTon:LSingleTon;</span><br><span class="line">27: aload_0</span><br><span class="line">28: monitorexit</span><br></pre></td></tr></table></figure><h1 id="二、为什么需要volatile？"><a href="#二、为什么需要volatile？" class="headerlink" title="二、为什么需要volatile？"></a>二、为什么需要volatile？</h1><h2 id="1-禁止指令重排序（有序性）"><a href="#1-禁止指令重排序（有序性）" class="headerlink" title="1. 禁止指令重排序（有序性）"></a>1. 禁止指令重排序（有序性）</h2><blockquote><p>实例化一个对象其实可以分为三个步骤：　　</p></blockquote><ol><li>分配内存空间。　　</li><li>初始化对象。　　</li><li>将内存空间的地址赋值给对应的引用。</li></ol><blockquote><p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：　　</p><ol><li>分配内存空间。　　</li><li>将内存空间的地址赋值给对应的引用。　　</li><li>初始化对象</li></ol></blockquote><h2 id="2-保证singleTon对象的可见性"><a href="#2-保证singleTon对象的可见性" class="headerlink" title="2. 保证singleTon对象的可见性"></a>2. 保证singleTon对象的可见性</h2><h1 id="三、如果synchronized里面不加if判断会发生什么？"><a href="#三、如果synchronized里面不加if判断会发生什么？" class="headerlink" title="三、如果synchronized里面不加if判断会发生什么？"></a>三、如果synchronized里面不加if判断会发生什么？</h1><blockquote><p>多个线程竞争synchronize锁，只有一个拿到，剩下的会在锁释放的时候再次进行new 操作，就会导致执行多次，出现多个实例。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍了双重锁的单例模式实现方式和部分问题解答（有道云笔记迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、代码实现&quot;&gt;&lt;a href=&quot;#一、代码实现&quot; class=&quot;headerlink&quot; title=&quot;一、代码实现&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://jiaohongwei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="剑指offer" scheme="https://jiaohongwei.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>阿里云OSS多个文件打包下载</title>
    <link href="https://jiaohongwei.github.io/2018/12/19/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8B%E8%BD%BD/"/>
    <id>https://jiaohongwei.github.io/2018/12/19/阿里云OSS多个文件打包下载/</id>
    <published>2018-12-19T14:13:17.000Z</published>
    <updated>2019-02-19T14:18:28.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在阿里云OSS文件只有下载单个文件的教程，本文介绍多个OSS文件压缩打包成zip下载的步骤。</p></blockquote><h1 id="一、添加Aliyun-Open-Services-SDK依赖"><a href="#一、添加Aliyun-Open-Services-SDK依赖" class="headerlink" title="一、添加Aliyun Open Services SDK依赖"></a>一、添加Aliyun Open Services SDK依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">openservices.version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">openservices.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.openservices<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-openservices<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;openservices.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="二、创建OSSClientUtil操作OSS"><a href="#二、创建OSSClientUtil操作OSS" class="headerlink" title="二、创建OSSClientUtil操作OSS"></a>二、创建OSSClientUtil操作OSS</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSSClientUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(OSSClientUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阿里云API的内或外网域名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENDPOINT = <span class="string">"http://oss-cn-beijing.aliyuncs.com"</span>;</span><br><span class="line">    <span class="comment">//阿里云API的密钥Access Key ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_KEY_ID = <span class="string">"xxxxxxxxx"</span>;</span><br><span class="line">    <span class="comment">//阿里云API的密钥Access Key Secret</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_KEY_SECRET = <span class="string">"xxxxxxxxxxxx"</span>;</span><br><span class="line">    <span class="comment">// 操作的 bucket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"xxx"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取阿里云OSS客户端对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OSSClient OSSClient = <span class="keyword">new</span> OSSClient(ENDPOINT, ACCESS_KEY_ID, ACCESS_KEY_SECRET);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建Bucket  --Bucket权限:私有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName bucket名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 新建Bucket成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">createBucket</span><span class="params">(OSSClient client, String bucketName)</span> </span>&#123;</span><br><span class="line">        Bucket bucket = client.createBucket(bucketName);</span><br><span class="line">        <span class="keyword">return</span> bucketName.equals(bucket.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    /**</span></span><br><span class="line"><span class="comment">//     * 删除Bucket</span></span><br><span class="line"><span class="comment">//     *</span></span><br><span class="line"><span class="comment">//     * @param bucketName bucket名称</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    public static final void deleteBucket(OSSClient client, String bucketName) &#123;</span></span><br><span class="line"><span class="comment">//        client.deleteBucket(bucketName);</span></span><br><span class="line"><span class="comment">//        logger.info("删除" + bucketName + "Bucket成功");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向阿里云的OSS存储中存储文件  --file也可以用InputStream替代</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client     OSS客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file       上传文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName bucket名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> diskName   上传文件的目录  --bucket下文件的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 唯一MD5数字签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">uploadObject2OSS</span><span class="params">(OSSClient client, File file, String bucketName, String diskName)</span> </span>&#123;</span><br><span class="line">        String resultStr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            String fileName = file.getName();</span><br><span class="line">            Long fileSize = file.length();</span><br><span class="line">            <span class="comment">//创建上传Object的Metadata</span></span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line"><span class="comment">//            metadata.setCacheControl("no-cache");</span></span><br><span class="line"><span class="comment">//            metadata.setHeader("Pragma", "no-cache");</span></span><br><span class="line">            metadata.setContentEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">            metadata.setContentType(getContentType(fileName));</span><br><span class="line"><span class="comment">//            metadata.setContentDisposition("filename/filesize=" + fileName + "/" + fileSize + "Byte.");</span></span><br><span class="line">            <span class="comment">//上传文件</span></span><br><span class="line">            PutObjectResult putResult = client.putObject(bucketName, diskName + fileName, is, metadata);</span><br><span class="line">            <span class="comment">//解析结果</span></span><br><span class="line">            resultStr = putResult.getETag();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取OSS服务器上的文件输入流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client     OSS客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName bucket名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> diskName   文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        Bucket下的文件的路径名+文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getOSS2InputStream</span><span class="params">(OSSClient client, String bucketName, String diskName, String key)</span> </span>&#123;</span><br><span class="line">        OSSObject ossObj = client.getObject(bucketName, diskName + key);</span><br><span class="line">        <span class="keyword">return</span> ossObj.getObjectContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getObjectInputStream</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        OSSObject ossObj = OSSClient.getObject(BUCKET_NAME, key);</span><br><span class="line">        <span class="keyword">return</span> ossObj.getObjectContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key删除OSS服务器上的文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> diskName Bucket下的文件的路径名+文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">(String diskName)</span> </span>&#123;</span><br><span class="line">        OSSClient.deleteObject(BUCKET_NAME, diskName);</span><br><span class="line">        logger.info(<span class="string">"删除"</span> + BUCKET_NAME + <span class="string">"下的文件"</span> + diskName + <span class="string">"成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过文件名判断并获取OSS服务文件上传时文件的contentType</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件的contentType</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">getContentType</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        String fileExtension = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"png"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/png"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"bmp"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/bmp"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"gif"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/gif"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"jpeg"</span>.equalsIgnoreCase(fileExtension) || <span class="string">"jpg"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/jpeg"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"html"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"text/html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"txt"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"text/plain"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"vsd"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"application/vnd.visio"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"ppt"</span>.equalsIgnoreCase(fileExtension) || <span class="string">"pptx"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"application/vnd.ms-powerpoint"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"doc"</span>.equalsIgnoreCase(fileExtension) || <span class="string">"docx"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"application/msword"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"text/xml"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"zip"</span>.equalsIgnoreCase(fileExtension)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"application/zip"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"text/html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到阿里云oss</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> diskName oss上文件的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上传文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scpFileToOss</span><span class="params">(String filePath, String diskName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上传文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        String md5key = uploadObject2OSS(OSSClient, file, BUCKET_NAME, diskName);</span><br><span class="line">        logger.info(<span class="string">"上传cdn成功，MD5数字唯一签名:"</span> + md5key);  <span class="comment">//上传后的文件MD5数字唯一签名:A30B046A34EB326C4A3BBD784333B017</span></span><br><span class="line">        String[] split = filePath.split(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">return</span> split[split.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scpFileToOss</span><span class="params">(File file, String diskName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上传文件</span></span><br><span class="line">        String md5key = uploadObject2OSS(OSSClient, file, BUCKET_NAME, diskName);</span><br><span class="line">        logger.info(<span class="string">"上传cdn成功，MD5数字唯一签名:"</span> + md5key);  <span class="comment">//上传后的文件MD5数字唯一签名:A30B046A34EB326C4A3BBD784333B017</span></span><br><span class="line">        <span class="keyword">return</span> md5key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传整个文件夹的文件到阿里云oss</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> folderPath 文件夹路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> diskName   oss上文件的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上传结果唯一MD5数字签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scpFolderToOss</span><span class="params">(String folderPath, String diskName)</span> </span>&#123;</span><br><span class="line">        File dirFile = <span class="keyword">new</span> File(folderPath);</span><br><span class="line">        <span class="keyword">if</span> (!dirFile.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件夹不存在"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dirFile.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"不是一个文件夹路径"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        File[] fileList = dirFile.listFiles();</span><br><span class="line">        Arrays.stream(fileList).forEach(file -&gt; scpFileToOss(file.getPath(), diskName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 OSS上的文件夹下所有文件</span></span><br><span class="line"><span class="comment">     * 需要先列出该文件下的所有对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> diskName 文件夹路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(String diskName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 列举Object。 如KeyPrifex参数为空，则列举Bucket下所有的Object。如KeyPrifex参数不为空，则列举包含指定前缀的Object。</span></span><br><span class="line">        <span class="comment">// 构造ListObjectsRequest请求。</span></span><br><span class="line">        ListObjectsRequest listObjectsRequest = <span class="keyword">new</span> ListObjectsRequest(BUCKET_NAME);</span><br><span class="line">        <span class="comment">//设置 Prefix 参数来获取某个目录（fun/）下的所有文件</span></span><br><span class="line">        System.out.println(diskName);</span><br><span class="line">        listObjectsRequest.setPrefix(diskName);</span><br><span class="line">        <span class="comment">// 递归列出fun目录下的所有文件。</span></span><br><span class="line">        ObjectListing listing = OSSClient.listObjects(listObjectsRequest);</span><br><span class="line">        <span class="comment">// 遍历所有Object。</span></span><br><span class="line">        System.out.println(<span class="string">"Objects:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (OSSObjectSummary objectSummary : listing.getObjectSummaries()) &#123;</span><br><span class="line">            System.out.println(objectSummary.getKey());</span><br><span class="line">            deleteFile(objectSummary.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、打包批量下载"><a href="#三、打包批量下载" class="headerlink" title="三、打包批量下载"></a>三、打包批量下载</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat format = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;);</span><br><span class="line">String prefixName = &quot;XXXXXX_SDK_&quot; + format.format(new Date());</span><br><span class="line">String fileName = prefixName + &quot;.zip&quot;;</span><br><span class="line">// 创建临时文件</span><br><span class="line">File zipFile = File.createTempFile(prefixName, &quot;.zip&quot;);</span><br><span class="line">FileOutputStream outputStream = new FileOutputStream(zipFile);</span><br><span class="line">/**</span><br><span class="line"> * 作用是为任何OutputStream产生校验和</span><br><span class="line"> * 第一个参数是制定产生校验和的输出流，第二个参数是指定Checksum的类型 （Adler32（较快）和CRC32两种）</span><br><span class="line"> */</span><br><span class="line">CheckedOutputStream csum = new CheckedOutputStream(outputStream, new Adler32());</span><br><span class="line">// 用于将数据压缩成Zip文件格式</span><br><span class="line">ZipOutputStream zos = new ZipOutputStream(csum);</span><br><span class="line">// 遍历所有的需要下载的oss文件</span><br><span class="line">for (SdkPackage sdkPackage : sdkPackages) &#123;</span><br><span class="line">    InputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">    // 获取输入流</span><br><span class="line">        inputStream = OSSClientUtil.getObjectInputStream(sdkPackage.getSdkURL());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // 文件不存在 或者 读取失败 跳过</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    // zip 中新建 entry实例 传入文件名</span><br><span class="line">    zos.putNextEntry(new ZipEntry(sdkPackage.getSdkName()));</span><br><span class="line">    int readCount = -1;</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    // 向压缩文件中输出数据</span><br><span class="line">    while ((readCount = inputStream.read(bytes)) != -1) &#123;</span><br><span class="line">        zos.write(bytes, 0, readCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputStream.close();</span><br><span class="line">    zos.closeEntry(); // 当前文件写完，定位为写入下一条项目</span><br><span class="line">&#125;</span><br><span class="line">zos.close();</span><br><span class="line">String header = request.getHeader(&quot;User-Agent&quot;).toUpperCase();</span><br><span class="line">if (header.contains(&quot;MSIE&quot;) || header.contains(&quot;TRIDENT&quot;) || header.contains(&quot;EDGE&quot;)) &#123;</span><br><span class="line">    fileName = URLEncoder.encode(fileName, &quot;utf-8&quot;);</span><br><span class="line">    fileName = fileName.replace(&quot;+&quot;, &quot;%20&quot;);    //IE下载文件名空格变+号问题</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    fileName = new String(fileName.getBytes(), &quot;ISO8859-1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">response.reset();</span><br><span class="line">response.setContentType(&quot;text/plain&quot;);</span><br><span class="line">response.setContentType(&quot;application/octet-stream; charset=utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Location&quot;, fileName);</span><br><span class="line">response.setHeader(&quot;Cache-Control&quot;, &quot;max-age=0&quot;);</span><br><span class="line">response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + fileName);</span><br><span class="line"></span><br><span class="line">FileInputStream fis = new FileInputStream(zipFile);</span><br><span class="line">BufferedInputStream buff = new BufferedInputStream(fis);</span><br><span class="line">BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream());</span><br><span class="line">byte[] car = new byte[1024];</span><br><span class="line">int l = 0;</span><br><span class="line">while (l &lt; zipFile.length()) &#123;</span><br><span class="line">    int j = buff.read(car, 0, 1024);</span><br><span class="line">    l += j;</span><br><span class="line">    out.write(car, 0, j);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭流</span><br><span class="line">fis.close();</span><br><span class="line">buff.close();</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">// 删除临时文件</span><br><span class="line">zipFile.delete();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在阿里云OSS文件只有下载单个文件的教程，本文介绍多个OSS文件压缩打包成zip下载的步骤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、添加Aliyun-Open-Services-SDK依赖&quot;&gt;&lt;a href=&quot;#一、添加Aliyu
      
    
    </summary>
    
    
      <category term="工具代码" scheme="https://jiaohongwei.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Base64编码原理</title>
    <link href="https://jiaohongwei.github.io/2018/12/11/Base64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/"/>
    <id>https://jiaohongwei.github.io/2018/12/11/Base64编码原理/</id>
    <published>2018-12-11T04:07:45.000Z</published>
    <updated>2019-02-17T04:25:45.463Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述Base64的编码原理（博客园文章迁移）</p></blockquote><ul><li>Base64是编码方式不是加密方式</li><li>标准的ASCII码 128个中96个可见字符，其余为不可见字符，为了避免不可见字符</li><li>使用了64个可见字符进行编码</li></ul><h1 id="一、原理步骤"><a href="#一、原理步骤" class="headerlink" title="一、原理步骤"></a>一、原理步骤</h1><p>例如：Hello</p><h2 id="1-先转成二进制"><a href="#1-先转成二进制" class="headerlink" title="1. 先转成二进制"></a>1. 先转成二进制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111 00000000</span><br></pre></td></tr></table></figure><h2 id="2-打乱重编码，以6个一组进行重编码，不满足的需要补0"><a href="#2-打乱重编码，以6个一组进行重编码，不满足的需要补0" class="headerlink" title="2. 打乱重编码，以6个一组进行重编码，不满足的需要补0"></a>2. 打乱重编码，以6个一组进行重编码，不满足的需要补0</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010010 000110 010101 101100 011011 000110 111100 000000</span><br></pre></td></tr></table></figure><ul><li>注意：为什么要6个一组，因为一共64个可见字符， 000000 转成十进制是0 ，111111 转成十进制是63，正好64个编号和64个可见字符一一对应。</li><li>24 是8 和6 的最小公倍数，所以要筹够24</li></ul><h2 id="3-然后6个一组转为十进制"><a href="#3-然后6个一组转为十进制" class="headerlink" title="3. 然后6个一组转为十进制"></a>3. 然后6个一组转为十进制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18 6 21 44 27 6 60 0</span><br></pre></td></tr></table></figure><ul><li>补出来的0 结尾都要变成=号</li></ul><h2 id="4-去Base64-对照表拿出相应的字符"><a href="#4-去Base64-对照表拿出相应的字符" class="headerlink" title="4. 去Base64 对照表拿出相应的字符"></a>4. 去Base64 对照表拿出相应的字符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SGVsbG8=</span><br></pre></td></tr></table></figure><h1 id="二、图解"><a href="#二、图解" class="headerlink" title="二、图解"></a>二、图解</h1><p><img src="/2018/12/11/Base64编码原理/20181211003958788.png" alt></p><h1 id="三、Base64索引表"><a href="#三、Base64索引表" class="headerlink" title="三、Base64索引表"></a>三、Base64索引表</h1><p><img src="/2018/12/11/Base64编码原理/20181211004306149.png" alt></p><h1 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h1><p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：</p><ul><li>先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。也就是说，当最后剩余两个八位字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；</li><li>如果最后剩余一个八位字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述Base64的编码原理（博客园文章迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Base64是编码方式不是加密方式&lt;/li&gt;
&lt;li&gt;标准的ASCII码 128个中96个可见字符，其余为不可见字符，为了避免不可见字符&lt;/li
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>开放API接口安全处理</title>
    <link href="https://jiaohongwei.github.io/2018/12/10/%E5%BC%80%E6%94%BEAPI%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86/"/>
    <id>https://jiaohongwei.github.io/2018/12/10/开放API接口安全处理/</id>
    <published>2018-12-10T04:15:00.000Z</published>
    <updated>2019-02-17T04:28:47.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述开放API接口安全处理策略（有道云笔记迁移）</p></blockquote><h1 id="一、开放API接口定义"><a href="#一、开放API接口定义" class="headerlink" title="一、开放API接口定义"></a>一、开放API接口定义</h1><blockquote><p>顾名思义，开放出来给其他人调用的API接口就是开放API接口。例如，短信接口、邮件接口。</p></blockquote><hr><h1 id="二、开放API的弱点"><a href="#二、开放API的弱点" class="headerlink" title="二、开放API的弱点"></a>二、开放API的弱点</h1><h2 id="1-数据窃取"><a href="#1-数据窃取" class="headerlink" title="1. 数据窃取"></a>1. 数据窃取</h2><blockquote><p>用户的密码等信息被不轨之人窃取，登录账号发布敏感信息，盗刷等。</p></blockquote><h2 id="2-数据篡改"><a href="#2-数据篡改" class="headerlink" title="2. 数据篡改"></a>2. 数据篡改</h2><blockquote><p>提交的数据被抓包后进行篡改后再提交。</p></blockquote><h2 id="3-数据泄露"><a href="#3-数据泄露" class="headerlink" title="3. 数据泄露"></a>3. 数据泄露</h2><blockquote><p>爬虫将业务数据甚至核心数据抓取，直接或间接造成损失。</p></blockquote><hr><h1 id="三、开放API解决方案"><a href="#三、开放API解决方案" class="headerlink" title="三、开放API解决方案"></a>三、开放API解决方案</h1><h2 id="1-RSA-DES-加密"><a href="#1-RSA-DES-加密" class="headerlink" title="1. RSA/DES 加密"></a>1. RSA/DES 加密</h2><h3 id="对称加密（DES、AES）"><a href="#对称加密（DES、AES）" class="headerlink" title="对称加密（DES、AES）"></a>对称加密（DES、AES）</h3><ul><li>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</li><li>对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。</li><li>对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</li></ul><h3 id="非对称加密（RSA）"><a href="#非对称加密（RSA）" class="headerlink" title="非对称加密（RSA）"></a>非对称加密（RSA）</h3><ul><li>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</li><li>目前最常用的非对称加密算法是RSA算法，是Rivest, Shamir, 和Adleman于1978年发明。</li><li>RSA可以用于加密和签名：</li></ul><p><img src="/2018/12/10/开放API接口安全处理/20181210231535322.png" alt></p><p><img src="/2018/12/10/开放API接口安全处理/20181210231740664.png" alt></p><ul><li>HTTPS即用到了对称加密也用到了非对称加密（收费，服务器开销大，性能略低）</li><li>RSA加密 Java 实现：</li></ul><h2 id="2-MD5-混淆算法"><a href="#2-MD5-混淆算法" class="headerlink" title="2. MD5 混淆算法"></a>2. MD5 混淆算法</h2><ul><li>是一种消息摘要算法，一种被广泛使用的密码散列函数，可以产生出一个128位的散列值，用于确保信息传输完整一致，防止篡改。</li><li>不可逆的</li><li>存储一些永远不需要还原的数据，如 密码、MAC地址、IMEI</li><li>通常配合salt 加盐来加密</li><li>现在可以破解的是 通过一个彩虹表碰撞进行暴力破解</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>接口文档规定，接口哪些字段（id+名称）进行MD5+salt 加密传输到后台，同样后台也按照相关规则计算，然后比对匹配</li></ul><h2 id="3-TOKEN-令牌"><a href="#3-TOKEN-令牌" class="headerlink" title="3. TOKEN 令牌"></a>3. TOKEN 令牌</h2><ul><li>略</li></ul><hr><h1 id="四、接口实战经验"><a href="#四、接口实战经验" class="headerlink" title="四、接口实战经验"></a>四、接口实战经验</h1><ol><li>不要用自增序列</li><li>日志加完整，防背锅</li><li>短信接口一定要加图形验证码、人机验证码，业务判断，尤其是注册接口（没有用户的任何信息）</li><li>幂等性（ 提交一次和多次结果是一样的）</li><li>时间戳（有效时间）</li></ol><blockquote><p>先获取服务器时间，当作参数一起MD5，然后后台校验MD5成功之后，判断有效时间是否在30s之内。</p></blockquote><hr><h1 id="五、关于RSA加密、解密疑惑"><a href="#五、关于RSA加密、解密疑惑" class="headerlink" title="五、关于RSA加密、解密疑惑"></a>五、关于RSA加密、解密疑惑</h1><ul><li>还有公钥和私钥到底哪个才是用来加密和哪个用来解密？</li><li>不要去硬记。</li><li>你只要想：既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</li><li>很多人没真正理解RSA的原理，两个大质数(p,q)乘积(n)难以逆向求解，所以pq是对等的，公钥和私钥也是对等的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述开放API接口安全处理策略（有道云笔记迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、开放API接口定义&quot;&gt;&lt;a href=&quot;#一、开放API接口定义&quot; class=&quot;headerlink&quot; title=&quot;一、开放API接口
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制笔记</title>
    <link href="https://jiaohongwei.github.io/2018/11/30/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiaohongwei.github.io/2018/11/30/Java反射机制笔记/</id>
    <published>2018-11-30T02:41:08.000Z</published>
    <updated>2019-02-16T15:03:36.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述-amp-应用场景"><a href="#一、概述-amp-应用场景" class="headerlink" title="一、概述&amp;应用场景"></a>一、概述&amp;应用场景</h1><ul><li>Java反射机制是在运行状态中，对于任意一个类（Class）文件，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意一个方法和属性；</li><li>这种动态获取的信息以及动态调用对象的方法的功能成为Java语言的反射机制。</li></ul><blockquote><p>简单说就是动态获取类中信息就是反射机制。</p></blockquote><blockquote><p>可以理解为对类的解剖。</p></blockquote><hr><h1 id="二、细节-amp-Class对象"><a href="#二、细节-amp-Class对象" class="headerlink" title="二、细节&amp;Class对象"></a>二、细节&amp;Class对象</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Class&#123;</span><br><span class="line">    提供获取字节码文件中的内容。</span><br><span class="line">    比如：</span><br><span class="line">    名称，字段，构造函数，一般函数</span><br><span class="line">&#125;</span><br><span class="line">// 该类就可以获取字节码文件中的所有内容，那么反射就是依靠该类完成的。</span><br></pre></td></tr></table></figure><ul><li>想要对一个类文件进行解刨，只需要获取到该类的字节码文件对象即可。</li></ul><blockquote><p>java.lang.Class<t> </t></p></blockquote><ul><li>Class类的类表示正在运行的Java应用程序中的类和接口。 </li><li>枚举是一种类，一个注释是一种界面。 每个数组也属于一个反映为类对象的类，该对象由具有相同元素类型和维数的所有数组共享。 </li><li>原始Java类型（ boolean ， byte ， char ， short ， int ， long ， float和double ），和关键字void也表示为类对象。 </li><li>类没有公共构造函数。 相反， 类对象由Java虚拟机自动构建，因为加载了类，并且通过调用类加载器中的defineClass方法。</li></ul><hr><h1 id="三、获取Class对象的三种方式"><a href="#三、获取Class对象的三种方式" class="headerlink" title="三、获取Class对象的三种方式"></a>三、获取Class对象的三种方式</h1><p>要想对字节码文件进行解刨，必须要有字节码文件对象</p><ol><li>Object类中的getClass方法</li><li>通过对象静态属性 .class来获取对应的Class对象</li><li>只要通过给定类的字符串名称就可以获取该类，更为拓展</li></ol><h2 id="1-object-getClass"><a href="#1-object-getClass" class="headerlink" title="1.  object.getClass()"></a>1.  object.getClass()</h2><blockquote><p>创建Person类</p></blockquote><p>必须要明确具体的类，并且要创建对象，麻烦。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hw.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/11/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"... show run ..."</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"privateMethod run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paramMethod</span><span class="params">(String str, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"paramMethod run..."</span> + str + <span class="string">": "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"staticMethod run ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"person run ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">"person param run ... name="</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试用例</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取Class对象的三种方式</span><br><span class="line"> * 1.Object类中的getClass()方法，必须要明确具体的类，并且要创建对象，麻烦。</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getClassObject_1() &#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    Class clazz = person.getClass();</span><br><span class="line"></span><br><span class="line">    Person person1 = new Person();</span><br><span class="line">    Class clazz1 = person1.getClass();</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz == clazz1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130000917879.png" alt></p><h2 id="2-Object-class"><a href="#2-Object-class" class="headerlink" title="2. Object.class"></a>2. Object.class</h2><p>相对简单，但是还是需要先明确类中的静态成员。不够拓展。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过对象静态属性 .class来获取对应的Class对象</span><br><span class="line"> */</span><br><span class="line">public void getClassObject_2() &#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Class-forName-className"><a href="#3-Class-forName-className" class="headerlink" title="3. Class.forName(className)"></a>3. Class.forName(className)</h2><p>这种方法只要有名称即可，更为方便，拓展性更强。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 方式三：只要通过给定类的字符串名称就可以获取该类，更为拓展，forName</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getClassObject_3() throws ClassNotFoundException &#123;</span><br><span class="line">    String className = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    Class clazz = Class.forName(className);</span><br><span class="line">    System.out.println(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130002216418.png" alt></p><hr><h1 id="四、获取Class中的构造函数"><a href="#四、获取Class中的构造函数" class="headerlink" title="四、获取Class中的构造函数"></a>四、获取Class中的构造函数</h1><h2 id="1-new创建对象"><a href="#1-new创建对象" class="headerlink" title="1. new创建对象"></a>1. new创建对象</h2><ul><li>早期创建对象,先根据被new的类的名称找寻该类的字节码文件，并加载进内存，并创建该字节码文件对象，并接着创建该接文件的对应的Person对象</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.hw.bean.Person p = new com.hw.bean.Person();</span><br></pre></td></tr></table></figure><h2 id="2-反射创建对象"><a href="#2-反射创建对象" class="headerlink" title="2. 反射创建对象"></a>2. 反射创建对象</h2><ul><li>找寻该名称类文件，并加载进内存，调用newInstance() 创建由此 类对象表示的类的新实例。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createNewObject_1() throws Exception &#123;</span><br><span class="line">    // 早期创建对象,先根据被new的类的名称找寻该类的字节码文件，并加载进内存，</span><br><span class="line">    // 并创建该字节码文件对象，并接着创建该接文件的对应的Person对象</span><br><span class="line">    com.hw.bean.Person p = new com.hw.bean.Person();</span><br><span class="line"></span><br><span class="line">    // 现在</span><br><span class="line">    String name = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    // 找寻该名称类文件，并加载进内存，并产生Class对象</span><br><span class="line">    Class clazz = Class.forName(name);</span><br><span class="line">    // 通过空参构造器获取实例</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/30/Java反射机制笔记/20181130004030863.png" alt></p><ul><li>当获取指定名称对应类中的所体现的对象时，而该对象初始化不是用空参数构造该怎么办呢？</li><li>既然是通过指定的构造函数，进行对象的初始化，所以应该先获取到构造函数。</li></ul><h2 id="3-获取Class中的构造函数"><a href="#3-获取Class中的构造函数" class="headerlink" title="3. 获取Class中的构造函数"></a>3. 获取Class中的构造函数</h2><blockquote><p>getConstructor(类&lt;?&gt;… parameterTypes) </p></blockquote><ul><li>返回一个 Constructor对象，该对象反映 Constructor对象表示的类的指定的公共 类函数。 </li><li>parameterTypes参数是以声明顺序标识构造函数的形式参数类型的类对象的数组。</li><li>如果此类对象表示在非静态上下文中声明的内部类，则形式参数类型将显式包围实例作为第一个参数。</li><li>反映的构造是这样表示的类的公共构造类对象，其形式参数类型匹配那些由指定的parameterTypes 。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createNewObject_2() throws Exception &#123;</span><br><span class="line">    String name = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    Class clazz = Class.forName(name);</span><br><span class="line">    // 获取指定方法参数的构造对象</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">    // 通过该构造器对象的newInstance()方法进行对象的初始化</span><br><span class="line">    Object obj = constructor.newInstance(&quot;小明&quot;, 22);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><p><img src="/2018/11/30/Java反射机制笔记/20181130005233982.png" alt></p><hr><h1 id="五、获取Class中的字段"><a href="#五、获取Class中的字段" class="headerlink" title="五、获取Class中的字段"></a>五、获取Class中的字段</h1><h2 id="1-getField-String-name"><a href="#1-getField-String-name" class="headerlink" title="1. getField(String name)"></a>1. getField(String name)</h2><ul><li>返回一个 Field对象，它反映此表示的类或接口的指定公共成员字段 类对象。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取字节码文件的字段</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Field name = clazz.getField(&quot;name&quot;);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130005820538.png" alt></p><p>报错，原因是字段是私有的。</p><p>要反映的字段由以下算法确定。 让C成为由该对象表示的类或接口： </p><ul><li>如果C声明一个具有指定名称的公共字段，那就是要反映的字段。 </li><li>如果在上述步骤1中没有找到字段，则将该算法递归地应用于C的每个直接超级接口。直接超级接口按照它们被声明的顺序被搜索。 </li><li>如果在上面的步骤1和2中没有找到字段，并且C具有超类S，则该算法在S上递归地调用。如果C没有超类，则抛出NoSuchFieldException 。 </li></ul><h2 id="2-getDeclaredField-String-name"><a href="#2-getDeclaredField-String-name" class="headerlink" title="2. getDeclaredField(String name)"></a>2. getDeclaredField(String name)</h2><ul><li>只获取本类 但包含私有</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line"></span><br><span class="line">    Field field = // clazz.getField(&quot;name&quot;);</span><br><span class="line">            clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    Object age = field.get(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130010456310.png" alt></p><p>还是报错，不能访问私有的</p><h2 id="3-AccessibleObject-属性"><a href="#3-AccessibleObject-属性" class="headerlink" title="3. AccessibleObject 属性"></a>3. AccessibleObject 属性</h2><ul><li>AccessibleObject类是Field，Method和Constructor对象的基类。 它提供了将反射对象标记为在使用它时抑制默认Java语言访问控制检查的功能。</li><li>当使用Fields，Methods或Constructors来设置或获取字段，调用方法，或创建和初始化新的类实例时，执行访问检查（对于public，默认（包）访问，受保护和私有成员）。</li></ul><blockquote><p>setAccessible(boolean flag)  暴力访问</p></blockquote><ul><li>将此对象的 accessible标志设置为指示的布尔值。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line"></span><br><span class="line">    Field field = // clazz.getField(&quot;name&quot;);</span><br><span class="line">            clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">    // 对私有字段的访问取消权限检查。暴力访问</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    // 对字段赋值</span><br><span class="line">    field.set(instance,&quot;张四&quot;);</span><br><span class="line">    Object name = field.get(instance);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130011330038.png" alt></p><hr><h1 id="六、获取Class中的方法"><a href="#六、获取Class中的方法" class="headerlink" title="六、获取Class中的方法"></a>六、获取Class中的方法</h1><h2 id="1-getMethods"><a href="#1-getMethods" class="headerlink" title="1. getMethods()"></a>1. getMethods()</h2><ul><li><p>获取的都是共有的方法（包括父类）</p></li><li><p>返回包含一个数组 方法对象反射由此表示的类或接口的所有公共方法 类对象，包括那些由类或接口和那些从超类和超接口继承的声明。</p></li><li>如果此类对象表示具有多个具有相同名称和参数类型但具有不同返回类型的公共方法的类型，则返回的数组对于每个此类方法都有一个方法对象。 </li><li>如果此类对象表示与类初始化方法的类型<clinit> ，则返回的阵列不具有相应的方法对象。 </clinit></li><li>如果此类对象表示一个数组类型，则返回的阵列具有方法对于每个由阵列类型从继承的公共方法对象Object 。 它不包含方法对象clone() 。 </li><li>如果此类对象表示一个接口，那么返回的数组不包含任何隐含声明的方法，从Object 。因此，如果在此接口或其任何超级接口中没有显式声明方法，则返回的数组的长度为0.（注意，表示类的类对象始终具有从Object公共方法）。 </li><li>如果此类对象表示原始类型或空值，则返回的数组的长度为0。 </li><li>由此类对象表示的类或接口的超级接口中声明的静态方法不被视为类或接口的成员。 </li><li>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取指定Class中的公共函数</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getMethodDemo() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130012039348.png" alt></p><h2 id="2-getDeclaredMethods"><a href="#2-getDeclaredMethods" class="headerlink" title="2. getDeclaredMethods()"></a>2. getDeclaredMethods()</h2><ul><li>获取本类中的所有的方法（包含私有的）</li><li>返回包含一个数组方法对象反射的类或接口的所有声明的方法，通过此表示类对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。 </li><li>如果此类对象表示具有多个具有相同名称和参数类型但具有不同返回类型的声明方法的类型，则返回的数组对于每个此类方法都有一个方法对象。 </li><li>如果此类对象表示具有类初始化方法的类型<clinit> ，则返回的阵列不具有相应的方法对象。 </clinit></li><li>如果此类对象表示没有声明方法的类或接口，则返回的数组的长度为0。 </li><li>如果这个类对象表示一个数组类型，一个基本类型，或者是void，则返回的数组的长度为0。 </li><li>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_2() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130012438582.png" alt></p><h2 id="3-getMethod-String-name-类-lt-gt-…-parameterTypes"><a href="#3-getMethod-String-name-类-lt-gt-…-parameterTypes" class="headerlink" title="3. getMethod(String name, 类&lt;?&gt;… parameterTypes)"></a>3. getMethod(String name, 类&lt;?&gt;… parameterTypes)</h2><ul><li>获取单个方法</li><li>返回一个方法对象，它反映此表示的类或接口的指定公共成员方法类对象。 </li><li>name参数是一个String它指定了所需方法的简单名称。 </li><li>parameterTypes参数是以声明顺序标识方法的形式参数类型的类对象的数组。 </li><li>如果parameterTypes是null ，它被视为一个空数组。 </li></ul><blockquote><p>方法无参 方式一：使用无参构造器（默认） method.invoke(o, null)</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_3() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    // 获取空参的一般方法</span><br><span class="line">    Method method = clazz.getMethod(&quot;show&quot;, null);</span><br><span class="line">    Object o = clazz.newInstance();</span><br><span class="line">    method.invoke(o, null);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130013410485.png" alt></p><blockquote><p>方法无参 方式二：使用有参构造器  method.invoke(o, null)</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_4() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    // 获取空参的一般方法</span><br><span class="line">    Method method = clazz.getMethod(&quot;show&quot;, null);</span><br><span class="line">    // 获取带参构造器</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    Object o = constructor.newInstance(&quot;小明&quot;, 12);</span><br><span class="line">    method.invoke(o, null);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130013645030.png" alt></p><blockquote><p>方法有参 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_5() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method method = clazz.getMethod(&quot;paramMethod&quot;, String.class, int.class);</span><br><span class="line">    // 获取带参构造器</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    Object o = constructor.newInstance(&quot;小明&quot;, 12);</span><br><span class="line">    method.invoke(o, &quot;张三&quot;, 18);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130014202027.png" alt></p><hr><h1 id="七、源码"><a href="#七、源码" class="headerlink" title="七、源码"></a>七、源码</h1><p>本章节源码: <a href="https://github.com/JiaoHongwei/Reflection" target="_blank" rel="noopener">ReflectDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述-amp-应用场景&quot;&gt;&lt;a href=&quot;#一、概述-amp-应用场景&quot; class=&quot;headerlink&quot; title=&quot;一、概述&amp;amp;应用场景&quot;&gt;&lt;/a&gt;一、概述&amp;amp;应用场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java反射机制是在运行状态中，对于任意
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
      <category term="反射" scheme="https://jiaohongwei.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>服务器部署Spring Boot .jar包应用</title>
    <link href="https://jiaohongwei.github.io/2018/11/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Spring-Boot-jar%E5%8C%85%E5%BA%94%E7%94%A8/"/>
    <id>https://jiaohongwei.github.io/2018/11/20/服务器部署Spring-Boot-jar包应用/</id>
    <published>2018-11-20T08:24:48.000Z</published>
    <updated>2019-02-17T08:34:18.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍常见的jar包应用在Linux服务器部署规范</p></blockquote><hr><h1 id="一、jar包提取出来maven打包（避免每次重复打相同的jar包）"><a href="#一、jar包提取出来maven打包（避免每次重复打相同的jar包）" class="headerlink" title="一、jar包提取出来maven打包（避免每次重复打相同的jar包）"></a>一、jar包提取出来maven打包（避免每次重复打相同的jar包）</h1><blockquote><p>pom.xml配置如下</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>nothing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nothing<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">attach</span>&gt;</span>false<span class="tag">&lt;/<span class="name">attach</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includeTypes</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">includeTypes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includeScope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">includeScope</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="二、常用Linux命令"><a href="#二、常用Linux命令" class="headerlink" title="二、常用Linux命令"></a>二、常用Linux命令</h1><ul><li>打包：<code>mvn clean package -DskipTests</code></li><li>运行：<code>nohup java -jar xxx.jar &gt;./logs/xxx.log 2&gt;&amp;1 &amp;</code></li><li>查询：<code>jps -l | grep xxx.jar</code></li><li>关闭：<code>kill -9 pid</code></li></ul><hr><h1 id="三、启动脚本startup-sh"><a href="#三、启动脚本startup-sh" class="headerlink" title="三、启动脚本startup.sh"></a>三、启动脚本startup.sh</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line">JAVA_HOME=<span class="string">"/opt/jvm/jdk1.8.0_141"</span></span><br><span class="line">APP_HOME=<span class="string">"/data/Project/backend"</span></span><br><span class="line">APP_LOG=<span class="string">"<span class="variable">$APP_HOME</span>/logs"</span></span><br><span class="line">APP_LIBS=<span class="string">"<span class="variable">$APP_HOME</span>/libs"</span></span><br><span class="line">APP_MAIN=<span class="string">"xxx.jar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JVM启动参数</span></span><br><span class="line"><span class="comment"># -server：一定要作为第一个参数，多个CPU时性能佳</span></span><br><span class="line"><span class="comment"># -Xloggc：记录GC日志，建议写成绝对路径，如此便可在任意目录下执行该shell脚本</span></span><br><span class="line"><span class="comment">#JAVA_OPTS="-server -Xms1048m -Xmx1048m -Xloggc:$APP_HOME/logs/gc.log"</span></span><br><span class="line">JAVA_OPTS=<span class="string">"-server -Xms1048m -Xmx1048m"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载依赖到classpath</span></span><br><span class="line"><span class="comment">#for lib in $&#123;APP_HOME&#125;/libs/*.jar;</span></span><br><span class="line"><span class="comment">#   do CLASSPATH=$&#123;lib&#125;:"$&#123;CLASSPATH&#125;";</span></span><br><span class="line"><span class="comment">#done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#for setting in $&#123;APP_HOME&#125;/config/*.setting;</span></span><br><span class="line"><span class="comment">#   do CLASSPATH=config/$&#123;setting##*/&#125;:"$&#123;CLASSPATH&#125;";</span></span><br><span class="line"><span class="comment">#done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#CLASSPATH=log4j.properties:"$&#123;CLASSPATH&#125;"</span></span><br><span class="line"><span class="comment">#CLASSPATH=$&#123;CLASSPATH&#125;:.:$&#123;APP_HOME&#125;/dailyload.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line"><span class="comment">#if [ -n "$1" ] ;</span></span><br><span class="line"><span class="comment">#then</span></span><br><span class="line"><span class="comment">#   dt=$1</span></span><br><span class="line"><span class="comment">#   if ! (echo $dt | grep -Eq "[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;" &amp;&amp; date -d $dt +%Y%m%d &gt;/dev/null 2&gt;&amp;1;)</span></span><br><span class="line"><span class="comment">#   then</span></span><br><span class="line"><span class="comment">#       echo "param can not convert to date : $dt"</span></span><br><span class="line"><span class="comment">#       exit 1</span></span><br><span class="line"><span class="comment">#   fi</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#   dt=`date -d "0 days ago" "+%Y-%m-%d"`</span></span><br><span class="line"><span class="comment">#fi</span></span><br><span class="line"></span><br><span class="line">args=<span class="string">"$*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化进程ID（0表示未启动）</span></span><br><span class="line">pid=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Java应用的PID</span></span><br><span class="line"><span class="function"><span class="title">getPID</span></span>()&#123;</span><br><span class="line">    javaps=`<span class="variable">$JAVA_HOME</span>/bin/jps -l | grep <span class="variable">$APP_MAIN</span>`</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$javaps</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        pid=`<span class="built_in">echo</span> <span class="variable">$javaps</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pid=0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Java应用程序</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 1、调用getPID()函数，刷新$pid全局变量</span></span><br><span class="line"><span class="comment"># 2、若程序已经启动（$pid不等于0），则提示程序已启动</span></span><br><span class="line"><span class="comment"># 3、若程序未被启动，则执行启动命令</span></span><br><span class="line"><span class="comment"># 4、启动命令执行后，再次调用getPID()函数</span></span><br><span class="line"><span class="comment"># 5、若步骤4执行后，程序的PID不等于0，则打印Success，反之打印Failed</span></span><br><span class="line"><span class="comment"># 注意：[echo -n]表示打印字符后不换行</span></span><br><span class="line"><span class="comment"># 注意：[nohup command &gt; /path/nohup.log &amp;]是将作业输出到nohup.log，否则它会输出到该脚本目录下的nohup.out中</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="title">startup</span></span>()&#123;</span><br><span class="line">    getPID</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$pid</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$APP_MAIN</span> already started(PID=<span class="variable">$pid</span>)"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">"Starting <span class="variable">$APP_MAIN</span>"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#方式1 可执行jar包(jar的MANIFEST.MF文件已指定主函数和依赖)</span></span><br><span class="line">        <span class="comment">#nohup $JAVA_HOME/bin/java $JAVA_OPTS -jar dailyload.jar $dt &gt; $APP_LOG/nohup.log &amp;</span></span><br><span class="line">        nohup java -Dloader.path=<span class="variable">$APP_LIBS</span> -jar <span class="variable">$APP_HOME</span>/xxx.jar &gt; /dev/null &amp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#方式2 不可执行jar包(需自己加载依赖到classpath)</span></span><br><span class="line">        <span class="comment">#nohup $JAVA_HOME/bin/java $JAVA_OPTS -Dfile.encoding=UTF-8 -classpath $CLASSPATH $APP_MAIN $args &gt; $APP_LOG/nohup.log &amp;</span></span><br><span class="line">        <span class="comment">#nohup $JAVA_HOME/bin/java $JAVA_OPTS -Dfile.encoding=UTF-8 -classpath $CLASSPATH $APP_MAIN $args &gt; /dev/null &amp;</span></span><br><span class="line"></span><br><span class="line">        getPID</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$pid</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"(PID=<span class="variable">$pid</span>)...[Success]"</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"[Failed]"</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">startup</span><br></pre></td></tr></table></figure><hr><h1 id="四、查询状态脚本-status-sh"><a href="#四、查询状态脚本-status-sh" class="headerlink" title="四、查询状态脚本 status.sh"></a>四、查询状态脚本 status.sh</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"></span><br><span class="line">APP_HOME=/data/Project/backend</span><br><span class="line">APP_MAIN=xxx.jar</span><br><span class="line"></span><br><span class="line">pid=0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getPID</span></span>()&#123;</span><br><span class="line">   javaps=`<span class="variable">$JAVA_HOME</span>/bin/jps -l | grep <span class="variable">$APP_MAIN</span>`</span><br><span class="line">   <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$javaps</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">      pid=`<span class="built_in">echo</span> <span class="variable">$javaps</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      pid=0</span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getServerStatus</span></span>()&#123;</span><br><span class="line">   getPID</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">   <span class="keyword">if</span> [ <span class="variable">$pid</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$APP_MAIN</span> is running(PID=<span class="variable">$pid</span>)"</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$APP_MAIN</span> is not running"</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getServerStatus</span><br></pre></td></tr></table></figure><hr><h1 id="五、关闭程序脚本-shutdown-sh"><a href="#五、关闭程序脚本-shutdown-sh" class="headerlink" title="五、关闭程序脚本 shutdown.sh"></a>五、关闭程序脚本 shutdown.sh</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"></span><br><span class="line">APP_HOME=/data/Project/backend/</span><br><span class="line">APP_MAIN=xxx.jar</span><br><span class="line"></span><br><span class="line">pid=0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getPID</span></span>()&#123;</span><br><span class="line">   javaps=`<span class="variable">$JAVA_HOME</span>/bin/jps -l | grep <span class="variable">$APP_MAIN</span>`</span><br><span class="line">   <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$javaps</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">      pid=`<span class="built_in">echo</span> <span class="variable">$javaps</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      pid=0</span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Java应用程序</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 1、调用getPID()函数，刷新$pid全局变量</span></span><br><span class="line"><span class="comment"># 2、若程序已经启动（$pid不等于0），则开始执行停止程序操作，否则提示程序未运行</span></span><br><span class="line"><span class="comment"># 3、使用[kill -9 PID]命令强制杀掉进程</span></span><br><span class="line"><span class="comment"># 4、使用[$?]获取上一句命令的返回值，若其为0，表示程序已停止运行，则打印Success，反之打印Failed</span></span><br><span class="line"><span class="comment"># 5、为防止Java程序被启动多次，这里增加了反复检查程序进程的功能，通过递归调用shutdown()函数的方式，反复kill</span></span><br><span class="line"><span class="comment"># 注意：Shell编程中，[$?]表示上一句命令或者上一个函数的返回值</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="title">shutdown</span></span>()&#123;</span><br><span class="line">   getPID</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">   <span class="keyword">if</span> [ <span class="variable">$pid</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> -n <span class="string">"Stopping <span class="variable">$APP_MAIN</span>(PID=<span class="variable">$pid</span>)..."</span></span><br><span class="line">      <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">      <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"[Success]"</span></span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"[Failed]"</span></span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      getPID</span><br><span class="line">      <span class="keyword">if</span> [ <span class="variable">$pid</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">         shutdown</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$APP_MAIN</span> is not running"</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"==============================================================================================="</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shutdown</span><br></pre></td></tr></table></figure><hr><h1 id="六、源码文件"><a href="#六、源码文件" class="headerlink" title="六、源码文件"></a>六、源码文件</h1><ul><li>完整源码： <a href="https://github.com/JiaoHongwei/Spring-Boot-Demos/tree/master/shell" target="_blank" rel="noopener">Spring-Boot-Demos/shell</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;介绍常见的jar包应用在Linux服务器部署规范&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一、jar包提取出来maven打包（避免每次重复打相同的jar包）&quot;&gt;&lt;a href=&quot;#一、jar包提取出来maven打包（避免每次重
      
    
    </summary>
    
    
      <category term="Spring Boot" scheme="https://jiaohongwei.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>NIO、BIO、AIO的区别，及NIO的应用和框架选型【转】</title>
    <link href="https://jiaohongwei.github.io/2018/11/17/NIO%E3%80%81BIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8F%8ANIO%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/"/>
    <id>https://jiaohongwei.github.io/2018/11/17/NIO、BIO、AIO的区别，及NIO的应用和框架选型/</id>
    <published>2018-11-17T14:10:57.000Z</published>
    <updated>2019-02-22T15:53:14.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>谈到并发编程就不得不提到NIO，以及相关的Java NIO框架Netty等，并且在很多面试中也经常提到NIO和AIO、同步和异步、阻塞和非阻塞等的区别。我先简短介绍下几个NIO相关的概念，然后再谈NIO重点掌握内容，以及Java NIO框架选型。</p></blockquote><h1 id="一、-BIO、NIO、AIO的区别"><a href="#一、-BIO、NIO、AIO的区别" class="headerlink" title="一、 BIO、NIO、AIO的区别"></a>一、 BIO、NIO、AIO的区别</h1><p><strong>IO模型主要分类：</strong></p><ul><li>同步(synchronous) IO和异步(asynchronous) IO</li><li>阻塞(blocking) IO和非阻塞(non-blocking)IO</li><li>同步阻塞(blocking-IO)简称BIO</li><li>同步非阻塞(non-blocking-IO)简称NIO</li><li>异步非阻塞(synchronous-non-blocking-IO)简称AIO</li></ul><h2 id="1-BIO-同步阻塞I-O模式"><a href="#1-BIO-同步阻塞I-O模式" class="headerlink" title="1. BIO (同步阻塞I/O模式)"></a>1. BIO (同步阻塞I/O模式)</h2><blockquote><p>数据的读取写入必须阻塞在一个线程内等待其完成。</p></blockquote><blockquote><p>这里使用那个经典的烧开水例子，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。</p></blockquote><h2 id="2-NIO（同步非阻塞）"><a href="#2-NIO（同步非阻塞）" class="headerlink" title="2. NIO（同步非阻塞）"></a>2. NIO（同步非阻塞）</h2><blockquote><p>同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。</p></blockquote><h2 id="3-AIO-（异步非阻塞I-O模型）"><a href="#3-AIO-（异步非阻塞I-O模型）" class="headerlink" title="3. AIO （异步非阻塞I/O模型）"></a>3. AIO （异步非阻塞I/O模型）</h2><blockquote><p>异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。</p></blockquote><h2 id="4-IO与NIO区别："><a href="#4-IO与NIO区别：" class="headerlink" title="4. IO与NIO区别："></a>4. IO与NIO区别：</h2><p><img src="/2018/11/17/NIO、BIO、AIO的区别，及NIO的应用和框架选型/556dd80a77b24181b4a15b71b8565e43.jpg" alt></p><h2 id="5-同步与异步的区别："><a href="#5-同步与异步的区别：" class="headerlink" title="5. 同步与异步的区别："></a>5. 同步与异步的区别：</h2><blockquote><p>同步：发送一个请求，等待返回，再发送下一个请求，同步可以避免出现死锁，脏读的发生。</p></blockquote><blockquote><p>异步：发送一个请求，不等待返回，随时可以再发送下一个请求，可以提高效率，保证并发。</p></blockquote><h2 id="6-阻塞和非阻塞"><a href="#6-阻塞和非阻塞" class="headerlink" title="6. 阻塞和非阻塞"></a>6. 阻塞和非阻塞</h2><blockquote><p>阻塞：传统的IO流都是阻塞式的。也就是说，当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务。在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降。</p></blockquote><blockquote><p>非阻塞：Java NIO是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。</p></blockquote><h2 id="7-BIO、NIO、AIO适用场景"><a href="#7-BIO、NIO、AIO适用场景" class="headerlink" title="7. BIO、NIO、AIO适用场景"></a>7. BIO、NIO、AIO适用场景</h2><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><h1 id="二、NIO的3个核心概念"><a href="#二、NIO的3个核心概念" class="headerlink" title="二、NIO的3个核心概念"></a>二、NIO的3个核心概念</h1><blockquote><p>NIO重点是把 <strong>Channel（通道）</strong>，<strong>Buffer（缓冲区）</strong>，<strong>Selector（选择器）</strong>三个类之间的关系弄清楚。</p></blockquote><h2 id="1-缓冲区Buffer"><a href="#1-缓冲区Buffer" class="headerlink" title="1. 缓冲区Buffer"></a>1. 缓冲区Buffer</h2><blockquote><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。</p></blockquote><blockquote><p><strong>在NIO中，所有的数据都是用缓冲区处理。</strong>这也就本文上面谈到的<strong>IO是面向流的，NIO是面向缓冲区的</strong>。</p></blockquote><blockquote><p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。</p></blockquote><blockquote><p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：</p></blockquote><ul><li>ByteBuffer：字节缓冲区</li><li>CharBuffer：字符缓冲区</li><li>ShortBuffer：短整型缓冲区</li><li>IntBuffer：整型缓冲区</li><li>LongBuffer：长整型缓冲区</li><li>FloatBuffer：浮点型缓冲区</li><li>DoubleBuffer：双精度浮点型缓冲区</li></ul><h2 id="2-通道Channel"><a href="#2-通道Channel" class="headerlink" title="2. 通道Channel"></a>2. 通道Channel</h2><blockquote><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p></blockquote><blockquote><p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p></blockquote><blockquote><p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p></blockquote><p>Channel有四种实现：</p><ol><li>FileChannel:是从文件中读取数据。</li><li>DatagramChannel:从UDP网络中读取或者写入数据。</li><li>SocketChannel:从TCP网络中读取或者写入数据。</li><li>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</li></ol><h2 id="3-多路复用器Selector"><a href="#3-多路复用器Selector" class="headerlink" title="3. 多路复用器Selector"></a>3. 多路复用器Selector</h2><blockquote><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p></blockquote><p>关键对象</p><ul><li>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</li><li>SelectorKey：通道监听关键字，通过它来监听通道状态。</li></ul><p>监听注册</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socketChannel.register(selector, SelectionKey.OP_READ); // 监听注册在Selector</span><br></pre></td></tr></table></figure><p>监听的事件有</p><ul><li>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</li><li>OP_READ: 读取就绪，socketChannel使用</li><li>OP_WRITE: 写入就绪，socketChannel使用</li><li>OP_CONNECT: 连接就绪，socketChannel使用</li></ul><h1 id="三、NIO的应用和框架"><a href="#三、NIO的应用和框架" class="headerlink" title="三、NIO的应用和框架"></a>三、NIO的应用和框架</h1><h2 id="1-NIO的应用"><a href="#1-NIO的应用" class="headerlink" title="1. NIO的应用"></a>1. NIO的应用</h2><blockquote><p>Java NIO成功的应用在了各种分布式、即时通信和中间件Java系统中，充分的证明了基于NIO构建的通信基础，是一种高效，且扩展性很强的通信架构。</p></blockquote><p>例如：Dubbo(服务框架)，就默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p><blockquote><p>Jetty、Mina、Netty、Dubbo、ZooKeeper等都是基于NIO方式实现。</p></blockquote><ul><li>Mina出身于开源界的大牛Apache组织</li><li>Netty出身于商业开源大亨Jboss</li><li>Dubbo阿里分布式服务框架</li></ul><h2 id="2-NIO框架"><a href="#2-NIO框架" class="headerlink" title="2. NIO框架"></a>2. NIO框架</h2><blockquote><p>特别是Netty是目前最流行的一个Java开源框架NIO框架，Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p></blockquote><blockquote><p>相比JDK原生NIO，Netty提供了相对十分简单易用的API，非常适合网络编程。</p></blockquote><blockquote><p>Mina和Netty这两个NIO框架的创作者是同一个人Trustin Lee 。Netty从某种程度上讲是Mina的延伸和扩展，解决了一些Mina上的设计缺陷，也优化了一下Mina上面的设计理念。</p></blockquote><p>另一方面Netty相比较Mina的优势：</p><ol><li>更容易学习</li><li>API更简单</li><li>详细的范例源码和API文档</li><li>更活跃的论坛和社区</li><li>更高的代码更新维护速度</li></ol><blockquote><p>Netty无疑是NIO框架的首选，它的健壮性、功能、性能、可定制性和可扩展性在同类框架都是首屈一指的，后续将重点详细谈Netty的实现原理以及实战场景。</p></blockquote><h1 id="四、作者声明"><a href="#四、作者声明" class="headerlink" title="四、作者声明"></a>四、作者声明</h1><p>转载请保留页面地址：<a href="http://youzhixueyuan.com/java-nio-introduce.html" target="_blank" rel="noopener">http://youzhixueyuan.com/java-nio-introduce.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;谈到并发编程就不得不提到NIO，以及相关的Java NIO框架Netty等，并且在很多面试中也经常提到NIO和AIO、同步和异步、阻塞和非阻塞等的区别。我先简短介绍下几个NIO相关的概念，然后再谈NIO重点掌握内容，以及Java NIO框架选型。&lt;
      
    
    </summary>
    
    
      <category term="高并发编程系列" scheme="https://jiaohongwei.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Restful架构API编码规范</title>
    <link href="https://jiaohongwei.github.io/2018/08/15/Restful%E6%9E%B6%E6%9E%84API%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://jiaohongwei.github.io/2018/08/15/Restful架构API编码规范/</id>
    <published>2018-08-15T15:23:39.000Z</published>
    <updated>2019-02-18T15:24:35.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h1><blockquote><p>目前比较成熟的一套互联网应用程序的API设计理论</p></blockquote><h1 id="一、协议"><a href="#一、协议" class="headerlink" title="一、协议"></a>一、协议</h1><blockquote><p>API与用户的通信协议，总是使用HTTPs协议。</p></blockquote><h1 id="二、域名"><a href="#二、域名" class="headerlink" title="二、域名"></a>二、域名</h1><blockquote><p>应该尽量将API部署在专用域名之下。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://api.xxxxxx.cn/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xxxxxx.cn/api/</span><br></pre></td></tr></table></figure><h1 id="三、版本（Versioning）"><a href="#三、版本（Versioning）" class="headerlink" title="三、版本（Versioning）"></a>三、版本（Versioning）</h1><blockquote><p>应该将API的版本号放入URL。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xxxxxx.cn/api/v1/</span><br></pre></td></tr></table></figure><blockquote><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。</p></blockquote><h1 id="四、路径（Endpoint）"><a href="#四、路径（Endpoint）" class="headerlink" title="四、路径（Endpoint）"></a>四、路径（Endpoint）</h1><blockquote><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xxxxxx.cn/api/v1/users</span><br><span class="line">https://xxxxxx.cn/api/v1/reports</span><br><span class="line">https://xxxxxx.cn/api/v1/jobs</span><br></pre></td></tr></table></figure><blockquote><p>URL中大小写不敏感，不要出现大写字母</p></blockquote><blockquote><p>_ 和 - 作为API URL连接单词都可以，但是驼峰命名法就算了</p></blockquote><h1 id="五、HTTP动词"><a href="#五、HTTP动词" class="headerlink" title="五、HTTP动词"></a>五、HTTP动词</h1><blockquote><p>对于资源的具体操作类型，由HTTP动词表示。</p></blockquote><blockquote><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p></blockquote><table><thead><tr><th>HTTP动词</th><th>描述</th></tr></thead><tbody><tr><td>GET（SELECT）</td><td>从服务器取出资源（一项或多项）。</td></tr><tr><td>POST（CREATE）</td><td>在服务器新建一个资源。</td></tr><tr><td>PUT（UPDATE）</td><td>在服务器更新资源（客户端提供改变后的完整资源）。</td></tr><tr><td>PATCH（UPDATE）</td><td>在服务器更新资源（客户端提供改变的属性）。</td></tr><tr><td>DELETE（DELETE）</td><td>从服务器删除资源。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET     /users：            列出所有的用户</span><br><span class="line"></span><br><span class="line">POST    /users：            新建一个用户</span><br><span class="line"></span><br><span class="line">GET     /users/$&#123;id&#125;：      获取某个用户的信息</span><br><span class="line"></span><br><span class="line">PUT     /users/$&#123;id&#125;：      更新某个用户的信息（提供该用户的全部信息）</span><br><span class="line"></span><br><span class="line">PATCH   /users/$&#123;id&#125;：      更新某个指定用户的信息（提供该用户的部分信息）</span><br><span class="line"></span><br><span class="line">DELETE  /users/$&#123;id&#125;：      删除某个用户</span><br></pre></td></tr></table></figure><h1 id="六、过滤信息（Filtering）"><a href="#六、过滤信息（Filtering）" class="headerlink" title="六、过滤信息（Filtering）"></a>六、过滤信息（Filtering）</h1><blockquote><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line"></span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line"></span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line"></span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line"></span><br><span class="line">?user_id=1：指定筛选条件</span><br></pre></td></tr></table></figure><h1 id="七、状态码（Status-Codes）"><a href="#七、状态码（Status-Codes）" class="headerlink" title="七、状态码（Status Codes）"></a>七、状态码（Status Codes）</h1><blockquote><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</span><br><span class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure><h1 id="八、错误处理（Error-handling）"><a href="#八、错误处理（Error-handling）" class="headerlink" title="八、错误处理（Error handling）"></a>八、错误处理（Error handling）</h1><blockquote><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: &quot;Invalid API key&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot项目中通常需要全局捕获异常，统一处理。</p></blockquote><blockquote><p>Spring全局异常处理并不能处理Filter中的异常。</p></blockquote><h1 id="九、返回结果"><a href="#九、返回结果" class="headerlink" title="九、返回结果"></a>九、返回结果</h1><blockquote><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /collection：返回资源对象的列表（数组）</span><br><span class="line">GET /collection/resource：返回单个资源对象</span><br><span class="line">POST /collection：返回新生成的资源对象</span><br><span class="line">PUT /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure><blockquote><p>可以自定义返回结果包装类、返回结果状态码和提示信息等。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;:100200,</span><br><span class="line">    &quot;msg&quot;:&quot;success&quot;,</span><br><span class="line">    &quot;data&quot;:null,</span><br><span class="line">    &quot;extra&quot;:null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十、接口安全问题"><a href="#十、接口安全问题" class="headerlink" title="十、接口安全问题"></a>十、接口安全问题</h1><blockquote><p>API的身份认证应该使用OAuth 2.0框架。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Restful-API&quot;&gt;&lt;a href=&quot;#Restful-API&quot; class=&quot;headerlink&quot; title=&quot;Restful API&quot;&gt;&lt;/a&gt;Restful API&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;目前比较成熟的一套互联网应用程序的API设
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Optional</title>
    <link href="https://jiaohongwei.github.io/2018/08/15/Java-8-Optional/"/>
    <id>https://jiaohongwei.github.io/2018/08/15/Java-8-Optional/</id>
    <published>2018-08-15T13:24:11.000Z</published>
    <updated>2019-02-20T13:28:00.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><ul><li>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</li><li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li><li>Optional 类的引入很好的解决空指针异常。</li></ul><h1 id="一、构造实例"><a href="#一、构造实例" class="headerlink" title="一、构造实例"></a>一、构造实例</h1><ul><li>Optional<user> opt = Optional.empty();        ##创建一个空 Optional</user></li><li>Optional<user> opt = Optional.of(user);        ##user不能为null</user></li><li>Optional<user> opt = Optional.ofNullable(user);    ##user可以为null</user></li></ul><h1 id="二、主要方法"><a href="#二、主要方法" class="headerlink" title="二、主要方法"></a>二、主要方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T get() </span><br><span class="line">public boolean isPresent()</span><br><span class="line">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</span><br><span class="line">public T orElse(T other)</span><br><span class="line">public T orElseGet(Supplier&lt;? extends T&gt; other)</span><br><span class="line">public void ifPresent(Consumer&lt;? super T&gt; consumer)</span><br><span class="line">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br><span class="line">public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</span><br><span class="line">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</span><br></pre></td></tr></table></figure><h1 id="三、开始使用"><a href="#三、开始使用" class="headerlink" title="三、开始使用"></a>三、开始使用</h1><p>没有 Optional 之前，都是这么来写~</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delJob</span><span class="params">(String jobId)</span> </span>&#123;</span><br><span class="line">    CheckJob object = checkJobRepository.findOne(Long.valueOf(jobId));</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="keyword">null</span>)&#123;</span><br><span class="line">        checkJobRepository.delete(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有了 Optional ，于是代码就开始这么写了……</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delJob</span><span class="params">(String jobId)</span> </span>&#123;</span><br><span class="line">    Optional&lt;CheckJob&gt; object = checkJobRepository.findById(Long.valueOf(jobId));</span><br><span class="line">    <span class="keyword">if</span> (object.isPresent()) &#123;</span><br><span class="line">        checkJobRepository.delete(object.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这…和没用有什么区别嘛。。</p><h1 id="四、正确姿势"><a href="#四、正确姿势" class="headerlink" title="四、正确姿势"></a>四、正确姿势</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delJobDemo</span><span class="params">(String jobId)</span> </span>&#123;</span><br><span class="line">    Optional&lt;CheckJob&gt; object = checkJobRepository.findById(Long.valueOf(jobId));</span><br><span class="line">    object.ifPresent(checkJob -&gt; checkJobRepository.delete(checkJob));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/account"</span>)</span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseRestResponse <span class="title">getAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BaseRestResponse.ok(userService.getUserWithAuthorities()</span><br><span class="line">    .map(UserDTO::<span class="keyword">new</span>)</span><br><span class="line">    .orElseThrow(() -&gt; <span class="keyword">new</span> InternalServerErrorException(<span class="string">"User could not be found"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、使用注意事项"><a href="#五、使用注意事项" class="headerlink" title="五、使用注意事项"></a>五、使用注意事项</h1><blockquote><p>直白的讲, 当我们还在以如下几种方式使用 Optional 时, 就得开始检视自己了</p></blockquote><ul><li>调用 isPresent() 方法时</li><li>调用 get() 方法时</li><li>Optional 类型作为类/实例属性时</li><li>Optional 类型作为方法参数时</li></ul><p>注意：<br></p><ol><li>isPresent() 与 obj != null 无任何分别， 而没有 isPresent() 作铺垫的 get() 调用在 IntelliJ IDEA 中会收到告警</li><li>Optional 类型不可被序列化, 用作字段类型会出问题<br>使用 Optional 时尽量不直接调用 Optional.get() 方法, Optional.isPresent() 更应该被视为一个私有方法, 应依赖于其他像 Optional.orElse(), Optional.orElseGet(), Optional.map() 等这样的方法</li></ol><h1 id="六、常见Optional使用demo"><a href="#六、常见Optional使用demo" class="headerlink" title="六、常见Optional使用demo"></a>六、常见Optional使用demo</h1><h2 id="1、存在即返回-无则提供默认值"><a href="#1、存在即返回-无则提供默认值" class="headerlink" title="1、存在即返回, 无则提供默认值"></a>1、存在即返回, 无则提供默认值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> user.orElse(<span class="keyword">null</span>);  <span class="comment">// 而不是 return user.isPresent() ? user.get() : null;return user.orElse(UNKNOWN_USER);</span></span><br></pre></td></tr></table></figure><h2 id="2、存在即返回-无则由函数来产生"><a href="#2、存在即返回-无则由函数来产生" class="headerlink" title="2、存在即返回, 无则由函数来产生"></a>2、存在即返回, 无则由函数来产生</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> user.orElseGet(() -&gt; fetchAUserFromDatabase()); </span><br><span class="line"><span class="comment">//而不要 return user.isPresent() ? user: fetchAUserFromDatabase();</span></span><br></pre></td></tr></table></figure><h2 id="3、存在才对它做点什么"><a href="#3、存在才对它做点什么" class="headerlink" title="3、存在才对它做点什么"></a>3、存在才对它做点什么</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">//而不要下边那样</span></span><br><span class="line"><span class="keyword">if</span> (user.isPresent()) &#123;</span><br><span class="line">System.out.println(user.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Optional类&quot;&gt;&lt;a href=&quot;#Optional类&quot; class=&quot;headerlink&quot; title=&quot;Optional类&quot;&gt;&lt;/a&gt;Optional类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Optional 类是一个可以为null的容器对象。如果值存在则isPr
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hash函数处理冲突的方法【转】</title>
    <link href="https://jiaohongwei.github.io/2018/03/20/Hash%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://jiaohongwei.github.io/2018/03/20/Hash函数处理冲突的方法/</id>
    <published>2018-03-20T13:26:33.000Z</published>
    <updated>2019-02-20T13:34:46.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文讲述哈希函数处理冲突的四种基本方法</p></blockquote><h1 id="一、开放定址法"><a href="#一、开放定址法" class="headerlink" title="一、开放定址法"></a>一、开放定址法</h1><blockquote><p>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 </p></blockquote><p>公式为：fi(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1) </p><p>对增量di有三种取法：</p><ol><li>线性探测再散列 di=1,2,3,……,m-1</li><li>平方探测再散列 di=1²,-1²,2²,-2²,3²,-3²,……,k²,-k²</li><li>随机探测再散列 di 是一组伪随机数列</li></ol><p>用开放定址法解决冲突的做法是：</p><blockquote><p>当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表中无待查的关键字，即查找失败。</p></blockquote><p>例如：</p><p>比如说，我们的关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34},表长为12。<br><br>我们用散列函数f(key) = key mod l2 <br><br>当计算前S个数{12,67,56,16,25}时，都是没有冲突的散列地址，直接存入：<br></p><p><img src="/2018/03/20/Hash函数处理冲突的方法/20170210213355178.png" alt></p><p>计算key = 37时，发现f(37) = 1，此时就与25所在的位置冲突。 <br><br>于是我们应用上面的公式f(37) = (f(37)+1) mod 12 = 2。于是将37存入下标为2的位置： </p><p><img src="/2018/03/20/Hash函数处理冲突的方法/20170210213443522.png" alt></p><h1 id="二、链地址法"><a href="#二、链地址法" class="headerlink" title="二、链地址法"></a>二、链地址法</h1><blockquote><p>链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。</p></blockquote><p>如：<br>  键值对k2, v2与键值对k1, v1通过计算后的索引值都为2，这时及产生冲突，但是可以通道next指针将k2, k1所在的节点连接起来，这样就解决了哈希的冲突问题 </p><p><img src="/2018/03/20/Hash函数处理冲突的方法/20170210213528336.jpg" alt></p><h1 id="三、再哈希法"><a href="#三、再哈希法" class="headerlink" title="三、再哈希法"></a>三、再哈希法</h1><blockquote><p>再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数<br>  计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</p></blockquote><h1 id="四、建立公共溢出区"><a href="#四、建立公共溢出区" class="headerlink" title="四、建立公共溢出区"></a>四、建立公共溢出区</h1><blockquote><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文讲述哈希函数处理冲突的四种基本方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、开放定址法&quot;&gt;&lt;a href=&quot;#一、开放定址法&quot; class=&quot;headerlink&quot; title=&quot;一、开放定址法&quot;&gt;&lt;/a&gt;一、开放定址法&lt;/h1
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux cp/rm/mv强制覆盖</title>
    <link href="https://jiaohongwei.github.io/2017/08/18/Linux-cp-rm-mv%E5%BC%BA%E5%88%B6%E8%A6%86%E7%9B%96/"/>
    <id>https://jiaohongwei.github.io/2017/08/18/Linux-cp-rm-mv强制覆盖/</id>
    <published>2017-08-18T10:34:00.000Z</published>
    <updated>2019-02-17T03:44:45.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述Linux下的cp/rm/mv强制覆盖以及在Java中的调用（博客园文章迁移）</p></blockquote><h1 id="一、Linux下的cp-rm-mv强制覆盖"><a href="#一、Linux下的cp-rm-mv强制覆盖" class="headerlink" title="一、Linux下的cp/rm/mv强制覆盖"></a>一、Linux下的cp/rm/mv强制覆盖</h1><h2 id="1-反斜杠（-）临时取消别名"><a href="#1-反斜杠（-）临时取消别名" class="headerlink" title="1. 反斜杠（\）临时取消别名"></a>1. 反斜杠（\）临时取消别名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]# \cp filename new/filename   </span><br><span class="line">[root@fz ~]#</span><br></pre></td></tr></table></figure><h2 id="2-unalias-取消别名"><a href="#2-unalias-取消别名" class="headerlink" title="2. unalias 取消别名"></a>2. unalias 取消别名</h2><blockquote><p>注意：这只是临时取消cp的别名，不是永久的</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# unalias cp   </span><br><span class="line">[root@localhost ~]# cp filename new/filename   </span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h2 id="3-修改默认配置文件"><a href="#3-修改默认配置文件" class="headerlink" title="3. 修改默认配置文件"></a>3. 修改默认配置文件</h2><blockquote><p>输入alias命令，看到系统内部使用的是cp、mv、rm -i 所以怎么输入都是提示覆盖。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]#</span><br><span class="line">[root@fz ~]# alias</span><br><span class="line">alias cdd=&apos;cd /home/data/android/&apos;</span><br><span class="line">alias cp=&apos;cp -i&apos;</span><br><span class="line">alias l=&apos;ls -la&apos;</span><br><span class="line">alias l.=&apos;ls -d .* --color=auto&apos;</span><br><span class="line">alias ll=&apos;ls -l --color=auto&apos;</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br><span class="line">alias mv=&apos;mv -i&apos;</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias tf=&apos;tail -f &apos;</span><br><span class="line">alias vc=&apos;vim ~/.bash_profile&apos;</span><br><span class="line">alias vs=&apos;source ~/.bash_profile&apos;</span><br><span class="line">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br></pre></td></tr></table></figure><blockquote><p>修改 ~/.bashrc ，在 “alias cp=’cp -i’ ”前添加<code>#</code>号注释后即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz test]# vi ~/.bashrc </span><br><span class="line"># .bashrc</span><br><span class="line"></span><br><span class="line"># User specific aliases and functions</span><br><span class="line"></span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">#alias cp=&apos;cp -i&apos;</span><br><span class="line">alias mv=&apos;mv -i&apos;</span><br><span class="line"></span><br><span class="line"># Source global definitions</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>重启或者执行 source ~/.bashrc 让命令生效</p></blockquote><h2 id="4-yes指令-管道-自动输入yes"><a href="#4-yes指令-管道-自动输入yes" class="headerlink" title="4. yes指令+管道 自动输入yes"></a>4. yes指令+管道 自动输入yes</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]# yes | cp filename new/filename   </span><br><span class="line">cp: overwrite `new/filename&apos;? [root@localhost ~]#</span><br></pre></td></tr></table></figure><hr><h1 id="二、Java后台调用Linux命令实现"><a href="#二、Java后台调用Linux命令实现" class="headerlink" title="二、Java后台调用Linux命令实现"></a>二、Java后台调用Linux命令实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void copyIcon() throws IOException, InterruptedException &#123;</span><br><span class="line">      Runtime r = Runtime.getRuntime();</span><br><span class="line">      String cmd_copy = &quot;\\cp -rf temp/AppIcon/*  icon/&quot;;    //copy并覆盖</span><br><span class="line">      String[] cmds = new String[]&#123;&quot;sh&quot;,&quot;-c&quot;,cmd_copy&#125;;</span><br><span class="line">      Process p = r.exec(cmds);</span><br><span class="line">      int result = p.waitFor();</span><br><span class="line">      if (result == 0)&#123;   //表示正常结束</span><br><span class="line">          logger.error(&quot;【copy appIcon 成功】&quot;);</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">          logger.error(&quot;【copy appIcon 失败】&quot;+cmd_copy);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述Linux下的cp/rm/mv强制覆盖以及在Java中的调用（博客园文章迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Linux下的cp-rm-mv强制覆盖&quot;&gt;&lt;a href=&quot;#一、Linux下的cp-rm-mv强制覆盖
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://jiaohongwei.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Oracle CLOB 笔记</title>
    <link href="https://jiaohongwei.github.io/2017/08/18/Oracle-CLOB-%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiaohongwei.github.io/2017/08/18/Oracle-CLOB-笔记/</id>
    <published>2017-08-18T06:36:19.000Z</published>
    <updated>2019-02-17T03:29:34.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述Oracle的CLOB大数据字段类型（博客园文章迁移）</p></blockquote><h1 id="一、Oracle中的varchar2类型"><a href="#一、Oracle中的varchar2类型" class="headerlink" title="一、Oracle中的varchar2类型"></a>一、Oracle中的varchar2类型</h1><ul><li>我们在Oracle数据库存储的字符数据一般是用VARCHAR2。VARCHAR2既分PL/SQL Data Types中的变量类型，也分Oracle Database中的字段类型，不同场景的最大长度不同。</li><li>在Oracle Database中，VARCHAR2 字段类型，最大值为4000；PL/SQL中 VARCHAR2 变量类型，最大字节长度为32767。</li><li>当 VARCHAR2 容纳不下我们需要存储的信息时，就出来的Oracle的大数据类型LOB( Large Object，大型对象)。</li></ul><hr><h1 id="二、Oarcle中的LOB类型"><a href="#二、Oarcle中的LOB类型" class="headerlink" title="二、Oarcle中的LOB类型"></a>二、Oarcle中的LOB类型</h1><ul><li>在Oracle中，LOB（Large Object，大型对象）类型的字段现在用得越来越多了。因为这种类型的字段，容量大（最多能容纳4GB的数据），且一个表中可以有多个这种类型的字段，很灵活，适用于数据量非常大的业务领域（如图象、档案等）。</li><li>LOB类型分为BLOB和CLOB两种：BLOB即二进制大型对象（Binary Large Object），适用于存贮非文本的字节流数据（如程序、图象、影音等）。</li><li>而CLOB，即字符型大型对象（Character Large Object），则与字符集相关，适于存贮文本型的数据（如历史档案、大部头著作等）。</li></ul><hr><h1 id="三、DB中使用CLOB类型字段"><a href="#三、DB中使用CLOB类型字段" class="headerlink" title="三、DB中使用CLOB类型字段"></a>三、DB中使用CLOB类型字段</h1><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h2><blockquote><p>（使用sql或者直接在PL/SQL客户端创建），字段类型CLOB</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create table</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TEMP</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">name</span>      VARCHAR2(<span class="number">200</span>),</span><br><span class="line">  age       <span class="built_in">NUMBER</span>,</span><br><span class="line">  temp_clob <span class="keyword">CLOB</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">tablespace</span> INSIGHTDATA3_TS</span><br><span class="line">  pctfree <span class="number">10</span></span><br><span class="line">  <span class="keyword">initrans</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">maxtrans</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">storage</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">initial</span> <span class="number">160</span>K</span><br><span class="line">    <span class="keyword">next</span> <span class="number">1</span>M</span><br><span class="line">    <span class="keyword">minextents</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">maxextents</span> <span class="keyword">unlimited</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h2 id="2-增删改查"><a href="#2-增删改查" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h2><p>先看一下使用普通方式的sql操作CLOB类型：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.name, t.temp_clob <span class="keyword">FROM</span> temp t; <span class="comment">--普通查询 INSERT INTO temp t VALUES ('Grand.Jon', 22, '加入博客园的第一天');</span></span><br></pre></td></tr></table></figure><p>查询因为不是varchar2类型，所以普通查询看不到CLOB类型的字段内容，结果如下</p><p><img src="/2017/08/18/Oracle-CLOB-笔记/20170818131552506.png" alt></p><p>而普通插入操作也会因为Oracle的隐式转换，默认把字符串转换成varchar2类型，一旦字符串内容超过varchar2的最大限度就会报会报ora-01704（字符串太长）错误。</p><p>正确操作：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用PL/SQL语法，采取绑定变量的方式解决，而不是直接拼接SQL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">       V_LANG <span class="keyword">CLOB</span> := <span class="string">'待插入的海量字符串'</span>;</span><br><span class="line">       </span><br><span class="line">       V_UPDATE CLOB := '更新的海量字符串';</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp t <span class="keyword">VALUES</span> (<span class="string">'Grand.Jon'</span>, <span class="number">22</span>, V_LANG);        <span class="comment">--增加</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> temp t <span class="keyword">SET</span> t.temp_clob = V_UPDATE <span class="keyword">WHERE</span> <span class="keyword">rownum</span> = <span class="number">1</span>;  <span class="comment">--修改</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> t.NAME, dbms_lob.substr(t.temp_clob) <span class="keyword">FROM</span> TEMP t;    <span class="comment">--查询　　将CLOB转成字符类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">DELETE</span> temp t <span class="keyword">WHERE</span> <span class="keyword">rownum</span> = <span class="number">1</span>;                             <span class="comment">--按列删除　　</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><blockquote><p>对CLOB的操作我们在存储过程中基本上使用 dbms_lob 中 substr , append , write 等方法。</p></blockquote><p>dbms_lob 方法总结</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">dbms_lob.createtemporary(V_SQL,true);     <span class="comment">--创建一个临时clob，用来存储拼接的sql</span></span><br><span class="line">dbms_lob.write(v_SQL,'写入信息');          <span class="comment">--写入操作</span></span><br><span class="line">dbms_lob.append(v_SQL,',');               <span class="comment">--拼接clob</span></span><br><span class="line">dbms_lob.substr(v_SQL);                   <span class="comment">--截取clob，不传参数就是全部读取</span></span><br><span class="line">dbms_lob.freetemporary(v_SQL);            <span class="comment">--释放clob</span></span><br></pre></td></tr></table></figure><p>查询结果如下：</p><p><img src="/2017/08/18/Oracle-CLOB-笔记/20170818133801834.png" alt></p><hr><h1 id="四、在存储过程中使用CLOB类型实例"><a href="#四、在存储过程中使用CLOB类型实例" class="headerlink" title="四、在存储过程中使用CLOB类型实例"></a>四、在存储过程中使用CLOB类型实例</h1><blockquote><p>需求：以开发的存储过程为例，需要循环遍历时间范围拼接sql，将时间日期按列反转（pivot），如果时间太长（1年以上）sql语句（varchar2）就会超出范围报错，这时候就需要使用CLOB来存储拼接的sql。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PROCEDURE P_AND_CPT_RATIOOTH_APP_BAK2_N(</span><br><span class="line">            V_APPIDS IN VARCHAR2,</span><br><span class="line">            V_TYPE IN VARCHAR2,</span><br><span class="line">            V_CHANNEL IN VARCHAR2,</span><br><span class="line">            V_TABLE IN VARCHAR2,</span><br><span class="line">            V_START IN VARCHAR2,</span><br><span class="line">            V_END IN VARCHAR2,</span><br><span class="line">            RESULT OUT mycursor</span><br><span class="line">) IS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">V_SQL CLOB;</span><br><span class="line">V_SQLWHERE VARCHAR2(32767) default  '';</span><br><span class="line">V_SQLWHERE_CHANNEL VARCHAR2(32767) default '';</span><br><span class="line">V_SQL_DATES  CLOB;</span><br><span class="line">V_Sdate  DATE;</span><br><span class="line">V_Edate  DATE;</span><br><span class="line">V_TABLE_DATE VARCHAR2(50);</span><br><span class="line">V_TABLE_TYPE VARCHAR2(50);</span><br><span class="line">V_START_DATE VARCHAR2(50);</span><br><span class="line">V_END_DATE   VARCHAR2(50);</span><br><span class="line"></span><br><span class="line">V_DAY VARCHAR2(50);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">select</span> column_name <span class="keyword">into</span> V_TABLE_DATE <span class="keyword">from</span> user_tab_columns <span class="keyword">where</span> table_name=<span class="string">''</span>||V_TABLE||<span class="string">''</span> <span class="keyword">and</span> column_id=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">select</span> column_name <span class="keyword">into</span> V_TABLE_TYPE <span class="keyword">from</span> user_tab_columns <span class="keyword">where</span> table_name=<span class="string">''</span>||V_TABLE||<span class="string">''</span> <span class="keyword">and</span> column_id=<span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">    dbms_lob.createtemporary(V_SQL,true);<span class="comment">--创建一个临时lob</span></span><br><span class="line">    dbms_lob.createtemporary(V_SQL_DATES,true);<span class="comment">--创建一个临时lob</span></span><br><span class="line">    </span><br><span class="line">    IF V_APPIDS is NOT NULL THEN</span><br><span class="line">       V_SQLWHERE := 'AND t.appid in ('||V_APPIDS||')';</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">    IF V_CHANNEL IS NOT NULL THEN</span><br><span class="line">       V_SQLWHERE_CHANNEL := 'AND t.channel = '''||V_CHANNEL||'''';</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    IF V_TABLE_DATE = 'MON' THEN</span><br><span class="line">       V_START_DATE := SUBSTR(V_START,0,6);</span><br><span class="line">       V_END_DATE :=  SUBSTR(V_END,0,6);</span><br><span class="line">       v_sdate := to_date(V_START_DATE, 'yyyymm');</span><br><span class="line">       v_edate := to_date(V_END_DATE, 'yyyymm');</span><br><span class="line">       </span><br><span class="line">        WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">              dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymm'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">        IF v_sdate != v_edate THEN</span><br><span class="line">              dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">        v_sdate := add_months(v_sdate,1);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    ELSE  <span class="comment">--周和日 类型 都是 DAY</span></span><br><span class="line">      </span><br><span class="line">       v_sdate := to_date(V_START, 'yyyymmdd');</span><br><span class="line">       v_edate := to_date(V_END, 'yyyymmdd');</span><br><span class="line">       V_END_DATE :=  V_END;</span><br><span class="line">       </span><br><span class="line">       IF SUBSTR(V_TYPE,0,1)='d' THEN</span><br><span class="line">            V_START_DATE := to_char(v_sdate, 'yyyymmdd');</span><br><span class="line"></span><br><span class="line">            WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">                  dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymmdd'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">            IF v_sdate != v_edate THEN</span><br><span class="line">                  dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">            v_sdate := v_sdate+1;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">       </span><br><span class="line">       ELSIF SUBSTR(V_TYPE,0,1)='w' THEN</span><br><span class="line"></span><br><span class="line">           <span class="keyword">select</span> to_char(V_Sdate,<span class="string">'d'</span>) <span class="keyword">INTO</span> V_DAY <span class="keyword">from</span> dual;</span><br><span class="line">            IF V_DAY!=2 THEN</span><br><span class="line">             V_Sdate:=V_Sdate-7;</span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">          V_START_DATE := to_char(v_sdate, 'yyyymmdd');</span><br><span class="line"></span><br><span class="line">          WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">               <span class="keyword">select</span> to_char(V_Sdate,<span class="string">'d'</span>) <span class="keyword">INTO</span> V_DAY <span class="keyword">from</span> dual;</span><br><span class="line">              IF V_DAY=2 THEN</span><br><span class="line">                 dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymmdd'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">                 IF V_Edate-v_sdate &gt;7 THEN</span><br><span class="line">                   dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">                 <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">            v_sdate := v_sdate+1;</span><br><span class="line">           <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    dbms_lob.append(v_sql,'<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>( <span class="keyword">SELECT</span> *</span><br><span class="line">            <span class="keyword">FROM</span> <span class="string">'||V_TABLE||'</span> t</span><br><span class="line">           <span class="keyword">WHERE</span> </span><br><span class="line">                 t.<span class="string">'||V_TABLE_TYPE||'</span> = <span class="string">'''||V_TYPE||'''</span></span><br><span class="line">             <span class="keyword">AND</span> t.<span class="string">'||V_TABLE_DATE||'</span> &gt;= <span class="string">'''||V_START_DATE||'''</span></span><br><span class="line">             <span class="keyword">AND</span> t.<span class="string">'||V_TABLE_DATE||'</span> &lt;= <span class="string">'''||V_END_DATE||'''</span></span><br><span class="line">             <span class="string">'||V_SQLWHERE||'</span>         </span><br><span class="line">             <span class="string">'||V_SQLWHERE_CHANNEL||'</span> ) t1</span><br><span class="line"> </span><br><span class="line">           <span class="keyword">pivot</span>(<span class="keyword">sum</span>(MARKETSHARE)</span><br><span class="line">             <span class="keyword">for</span> <span class="string">'||V_TABLE_DATE||'</span> <span class="keyword">in</span>(<span class="string">');</span></span><br><span class="line"><span class="string">             </span></span><br><span class="line"><span class="string">    dbms_lob.append(v_sql,v_SQL_DATES);</span></span><br><span class="line"><span class="string">    dbms_lob.append(v_sql,'</span>))<span class="string">');</span></span><br><span class="line"><span class="string">    dbms_output.put_line(v_sql);      </span></span><br><span class="line"><span class="string">    OPEN result FOR v_sql;   </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">       dbms_lob.freetemporary(v_sql);--释放lob</span></span><br><span class="line"><span class="string">       dbms_lob.freetemporary(v_SQL_DATES);--释放lob</span></span><br><span class="line"><span class="string">       --dbms_output.put_line(V_SQLDATE);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      -- dbms_output.put_line(v_SQL_DATES);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--记录操作日志及错误日志</span></span><br><span class="line"><span class="string">END;</span></span><br></pre></td></tr></table></figure><hr><h1 id="五、使用Java开发操作CLOB字段"><a href="#五、使用Java开发操作CLOB字段" class="headerlink" title="五、使用Java开发操作CLOB字段"></a>五、使用Java开发操作CLOB字段</h1><h2 id="1-原生JDBC处理CLOB类型"><a href="#1-原生JDBC处理CLOB类型" class="headerlink" title="1. 原生JDBC处理CLOB类型"></a>1. 原生JDBC处理CLOB类型</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><blockquote><p>增加，一般会插入一个空的clob到数据库对应的字段,然后锁定该列，用Write将待插入字符串写入进去。</p></blockquote><ul><li>重点：这两步操作要放在同一个事务里面。具体增加的方法如下:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean save(Article article)&#123;</span><br><span class="line">    boolean result = true;</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;insert into temp values(?,?,empty_clob())&quot;;</span><br><span class="line">    //锁住该列，防止并发写入时候该字段同时被多次写入造成错误</span><br><span class="line">    String sqlClob = &quot;select temp_clob from temp t where t.name=? for update&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    Writer writer = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        conn.setAutoCommit(false);//设置不自动提交，开启事务</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setString(1,article.getName());</span><br><span class="line">        pst.setString(2,article.getAge());</span><br><span class="line">        pst.executeUpdate();</span><br><span class="line"></span><br><span class="line">        pst= conn.prepareStatement(sqlClob);</span><br><span class="line">        pst.setInt(1, article.getId());</span><br><span class="line"></span><br><span class="line">        rs = pst.executeQuery();</span><br><span class="line">        CLOB clob = null;</span><br><span class="line">        if(rs.next())&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clob = (CLOB) rs.getClob(1);</span><br><span class="line">                writer = clob.getCharacterOutputStream(); //拿到clob的字符输入流</span><br><span class="line">                writer.write(article.getContent());</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        result = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn.rollback();//当commit或者rollback后会自动释放该列的锁定</span><br><span class="line">        &#125; catch (SQLException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        conn.setAutoCommit(true);//还原</span><br><span class="line">        ConnectionUntils.close(rs, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><blockquote><p>update操作，update时候主要利用PreparedStatement的setClob方法:</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean update(String name,String content)&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;update temp set temp_clob=? where name=?&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    try &#123;</span><br><span class="line">        CLOB clob   = oracle.sql.CLOB.createTemporary(conn, false,oracle.sql.CLOB.DURATION_SESSION);</span><br><span class="line">        clob.setString(1L, content);</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setClob(1, clob);</span><br><span class="line">        pst.setString(2,name);</span><br><span class="line">        result = pst.executeUpdate();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        ConnectionUntils.close(null, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    if(result==0)</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><blockquote><p>查询就主要是从结果集ResultSet中定位到对应的字段后，往外读：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Article select(String name)&#123;</span><br><span class="line">    Article article = new Article();</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;select name,age,temp_clog from temp where name = ?&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setInt(1,id);</span><br><span class="line">        rs = pst.executeQuery();</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        if(rs.next())&#123;</span><br><span class="line">            Clob clob = rs.getClob(&quot;temp_clog&quot;);</span><br><span class="line">            Reader rd = clob.getCharacterStream();</span><br><span class="line">            char [] str = new char[12];</span><br><span class="line">            while(rd.read(str) != -1) &#123;</span><br><span class="line">                builder.append(new String(str));</span><br><span class="line">            &#125;</span><br><span class="line">            article.setContent(builder.toString());</span><br><span class="line">            article.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">            article.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        ConnectionUntils.close(rs, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    return article;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Hibernate、Mybatis框架操作"><a href="#2-Hibernate、Mybatis框架操作" class="headerlink" title="2. Hibernate、Mybatis框架操作"></a>2. Hibernate、Mybatis框架操作</h2><blockquote><p>因为框架都封装集成好了，所以我们使用的时候直接配置变量的类型为CLOB就可以。</p></blockquote><p>譬如：Mybatis</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"temp_clob"</span> <span class="attr">property</span>=<span class="string">"content"</span> <span class="attr">jdbcType</span>=<span class="string">"Clob"</span>  <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.ClobTypeHandler"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>貌似Hibernate5内部做了对应的处理，可以直接当string类型一样处理即可。</p><hr><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><blockquote><p>虽然CLOB能解决VARCHAR2字符大小的限制，但是我们的DBA们都不建议用这些来处理，可能效率问题吧，大的文件应该放在服务器上，然后Database中存响应地址即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述Oracle的CLOB大数据字段类型（博客园文章迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Oracle中的varchar2类型&quot;&gt;&lt;a href=&quot;#一、Oracle中的varchar2类型&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://jiaohongwei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Oracle" scheme="https://jiaohongwei.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="https://jiaohongwei.github.io/2017/04/02/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://jiaohongwei.github.io/2017/04/02/数组中重复的数字/</id>
    <published>2017-04-02T02:27:03.000Z</published>
    <updated>2019-02-23T04:09:24.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><blockquote><p>在长度为n的数组中，所有的元素都是0到n-1的范围内。 数组中的某些数字是重复的，但不知道有几个重复的数字，也不知道重复了几次，请找出任意重复的数字。 例如，输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出为2或3</p></blockquote><h2 id="解法一：排序扫描"><a href="#解法一：排序扫描" class="headerlink" title="解法一：排序扫描"></a>解法一：排序扫描</h2><blockquote><p>将输入的数组进行排序，遍历排序后的数组找到重复的数字。排序一个长度为n的数字的时间复杂度为$\omicron(nlogn)$,所以这种方法的时间复杂度为$\omicron(nlogn)$。</p></blockquote><h2 id="解法二：使用哈希表"><a href="#解法二：使用哈希表" class="headerlink" title="解法二：使用哈希表"></a>解法二：使用哈希表</h2><blockquote><p>使用哈希表来解决这个问题。从头到尾顺序扫描数组中的每一个数，没扫描一个数字可以用$\omicron(1)$的时间在哈希表中判断是否包含此数字，如果哈希表中没有此数字就将此数字加入到哈希表中，如果哈希表中已存在此数字就找到重复的数字。时间复杂度为$\omicron(n)$，但是空间复杂度也为$\omicron(n)$，以空间换区时间。</p></blockquote><h2 id="解法三：比较交换"><a href="#解法三：比较交换" class="headerlink" title="解法三：比较交换"></a>解法三：比较交换</h2><blockquote><p>数组中的数字为0到n-1的范围内。如果这个数组中没有重复的数字，则对应的i位置的数据也为i。可以重排此数组，扫描数组中的每个数字，当扫描到下标为i的数字时，首先比较这个数字（m）是不是等于i。如果是，接着扫描下一个数字。如果不是，再拿它和第m个数字比较，如果相等则找到重复的数据。否则就把第i个数字与第m个数字交换。重复这个比较、交换的过程，直到找到重复的数字。</p></blockquote><blockquote><p>代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到属于它自己的位置，因此总的复杂度是$\omicron(n)$，另外所有的操作都是在输入数组上进行的，不需要额外的分配内存，空间复杂度为$\omicron(1)$</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuplicateNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] duplication = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> bool = duplicate(numbers, numbers.length, duplication);</span><br><span class="line">        <span class="keyword">if</span> (bool) &#123;</span><br><span class="line">            System.out.println(duplication[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"数组中无重复数字！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (numbers[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[numbers[i]] == numbers[i]) &#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = numbers[i];</span><br><span class="line">                numbers[i] = numbers[temp];</span><br><span class="line">                numbers[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在长度为n的数组中，所有的元素都是0到n-1的范围内。 数组中的某些数字是重复的，
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://jiaohongwei.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>Java Socket编程【转】</title>
    <link href="https://jiaohongwei.github.io/2017/03/06/Java-Socket%E7%BC%96%E7%A8%8B/"/>
    <id>https://jiaohongwei.github.io/2017/03/06/Java-Socket编程/</id>
    <published>2017-03-06T06:29:46.000Z</published>
    <updated>2019-02-17T06:52:27.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java-Socket简介"><a href="#一、Java-Socket简介" class="headerlink" title="一、Java Socket简介"></a>一、Java Socket简介</h1><blockquote><p>对于Java Socket编程而言，有两个概念，一个是ServerSocket，一个是Socket。服务端和客户端之间通过Socket建立连接，之后它们就可以进行通信了。首先ServerSocket将在服务端监听某个端口，当发现客户端有Socket来试图连接它时，它会accept该Socket的连接请求，同时在服务端建立一个对应的Socket与之进行通信。这样就有两个Socket了，客户端和服务端各一个。</p></blockquote><blockquote><p>对于Socket之间的通信其实很简单，服务端往Socket的输出流里面写东西，客户端就可以通过Socket的输入流读取对应的内容。Socket与Socket之间是双向连通的，所以客户端也可以往对应的Socket输出流里面写东西，然后服务端对应的Socket的输入流就可以读出对应的内容。</p></blockquote><h1 id="二、服务端与客户端通信的例子"><a href="#二、服务端与客户端通信的例子" class="headerlink" title="二、服务端与客户端通信的例子"></a>二、服务端与客户端通信的例子</h1><h2 id="1-客户端写服务端读"><a href="#1-客户端写服务端读" class="headerlink" title="1. 客户端写服务端读"></a>1. 客户端写服务端读</h2><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常信息都往外抛  </span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">8899</span>;  </span><br><span class="line">      <span class="comment">//定义一个ServerSocket监听在端口8899上  </span></span><br><span class="line">      ServerSocket server = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">      <span class="comment">//server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span></span><br><span class="line">      Socket socket = server.accept();  </span><br><span class="line">      <span class="comment">//跟客户端建立好连接之后，我们就可以获取socket的InputStream，并从中读取客户端发过来的信息了。  </span></span><br><span class="line">      Reader reader = <span class="keyword">new</span> InputStreamReader(socket.getInputStream());  </span><br><span class="line">      <span class="keyword">char</span> chars[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];  </span><br><span class="line">      <span class="keyword">int</span> len;  </span><br><span class="line">      StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">      <span class="keyword">while</span> ((len=reader.read(chars)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">         sb.append(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(<span class="string">"from client: "</span> + sb);  </span><br><span class="line">      reader.close();  </span><br><span class="line">      socket.close();  </span><br><span class="line">      server.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>服务端从Socket的InputStream中读取数据的操作也是阻塞式的，如果从输入流中没有读取到数据程序会一直在那里不动，直到客户端往Socket的输出流中写入了数据，或关闭了Socket的输出流。当然，对于客户端的Socket也是同样如此。在操作完以后，整个程序结束前记得关闭对应的资源，即关闭对应的IO流和Socket。</p></blockquote><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">      //为了简单起见，所有的异常都直接往外抛  </span><br><span class="line">      String host = &quot;127.0.0.1&quot;;  //要连接的服务端IP地址  </span><br><span class="line">      int port = 8899;   //要连接的服务端对应的监听端口  </span><br><span class="line">      //与服务端建立连接  </span><br><span class="line">      Socket client = new Socket(host, port);  </span><br><span class="line">      //建立连接后就可以往服务端写数据了  </span><br><span class="line">      Writer writer = new OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Server.&quot;);  </span><br><span class="line">      writer.flush();//写完后要记得flush  </span><br><span class="line">      writer.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于客户端往Socket的输出流里面写数据传递给服务端要注意一点，如果写操作之后程序不是对应着输出流的关闭，而是进行其他阻塞式的操作（比如从输入流里面读数据），记住要flush一下，只有这样服务端才能收到客户端发送的数据，否则可能会引起两边无限的互相等待。在稍后讲到客户端和服务端同时读和写的时候会说到这个问题。</p></blockquote><h2 id="2-客户端和服务端同时读和写"><a href="#2-客户端和服务端同时读和写" class="headerlink" title="2. 客户端和服务端同时读和写"></a>2. 客户端和服务端同时读和写</h2><h3 id="服务端代码-1"><a href="#服务端代码-1" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常信息都往外抛  </span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">8899</span>;  </span><br><span class="line">      <span class="comment">//定义一个ServerSocket监听在端口8899上  </span></span><br><span class="line">      ServerSocket server = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">      <span class="comment">//server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span></span><br><span class="line">      Socket socket = server.accept();  </span><br><span class="line">      <span class="comment">//跟客户端建立好连接之后，我们就可以获取socket的InputStream，并从中读取客户端发过来的信息了。  </span></span><br><span class="line">      Reader reader = <span class="keyword">new</span> InputStreamReader(socket.getInputStream());  </span><br><span class="line">      <span class="keyword">char</span> chars[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];  </span><br><span class="line">      <span class="keyword">int</span> len;  </span><br><span class="line">      StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">      <span class="keyword">while</span> ((len=reader.read(chars)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">         sb.append(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(<span class="string">"from client: "</span> + sb);  </span><br><span class="line">      <span class="comment">//读完后写一句  </span></span><br><span class="line">      Writer writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">      writer.write(<span class="string">"Hello Client."</span>);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      writer.close();  </span><br><span class="line">      reader.close();  </span><br><span class="line">      socket.close();  </span><br><span class="line">      server.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中首先我们从输入流中读取客户端发送过来的数据，接下来我们再往输出流里面写入数据给客户端，接下来关闭对应的资源文件。而实际上上述代码可能并不会按照我们预先设想的方式运行，因为从输入流中读取数据是一个阻塞式操作，在上述的while循环中当读到数据的时候就会执行循环体，否则就会阻塞，这样后面的写操作就永远都执行不了了。除非客户端对应的Socket关闭了阻塞才会停止，while循环也会跳出。针对这种可能永远无法执行下去的情况的解决方法是while循环需要在里面有条件的跳出来，纵观上述代码，在不断变化的也只有取到的长度len和读到的数据了，len已经是不能用的了，唯一能用的就是读到的数据了。针对这种情况，通常我们都会约定一个结束标记，当客户端发送过来的数据包含某个结束标记时就说明当前的数据已经发送完毕了，这个时候我们就可以进行循环的跳出了。那么改进后的代码会是这个样子：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Server &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws IOException &#123;  </span><br><span class="line">      //为了简单起见，所有的异常信息都往外抛  </span><br><span class="line">      int port = 8899;  </span><br><span class="line">      //定义一个ServerSocket监听在端口8899上  </span><br><span class="line">      ServerSocket server = new ServerSocket(port);  </span><br><span class="line">      //server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span><br><span class="line">      Socket socket = server.accept();  </span><br><span class="line">      //跟客户端建立好连接之后，我们就可以获取socket的InputStream，并从中读取客户端发过来的信息了。  </span><br><span class="line">      Reader reader = new InputStreamReader(socket.getInputStream());  </span><br><span class="line">      char chars[] = new char[64];  </span><br><span class="line">      int len;  </span><br><span class="line">      StringBuilder sb = new StringBuilder();  </span><br><span class="line">      String temp;  </span><br><span class="line">      int index;  </span><br><span class="line">      while ((len=reader.read(chars)) != -1) &#123;  </span><br><span class="line">         temp = new String(chars, 0, len);  </span><br><span class="line">         if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;//遇到eof时就结束接收  </span><br><span class="line">            sb.append(temp.substring(0, index));  </span><br><span class="line">            break;  </span><br><span class="line">         &#125;  </span><br><span class="line">         sb.append(temp);  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(&quot;from client: &quot; + sb);  </span><br><span class="line">      //读完后写一句  </span><br><span class="line">      Writer writer = new OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Client.&quot;);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      writer.close();  </span><br><span class="line">      reader.close();  </span><br><span class="line">      socket.close();  </span><br><span class="line">      server.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，当服务端读取到客户端发送的结束标记，即“eof”时就会结束数据的接收，终止循环，这样后续的代码又可以继续进行了。</p></blockquote><h3 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">      //为了简单起见，所有的异常都直接往外抛  </span><br><span class="line">     String host = &quot;127.0.0.1&quot;;  //要连接的服务端IP地址  </span><br><span class="line">     int port = 8899;   //要连接的服务端对应的监听端口  </span><br><span class="line">     //与服务端建立连接  </span><br><span class="line">     Socket client = new Socket(host, port);  </span><br><span class="line">      //建立连接后就可以往服务端写数据了  </span><br><span class="line">     Writer writer = new OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Server.&quot;);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      //写完以后进行读操作  </span><br><span class="line">     Reader reader = new InputStreamReader(client.getInputStream());  </span><br><span class="line">      char chars[] = new char[64];  </span><br><span class="line">      int len;  </span><br><span class="line">      StringBuffer sb = new StringBuffer();  </span><br><span class="line">      while ((len=reader.read(chars)) != -1) &#123;  </span><br><span class="line">         sb.append(new String(chars, 0, len));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(&quot;from server: &quot; + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      reader.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中我们先是给服务端发送了一段数据，之后读取服务端返回来的数据，跟之前的服务端一样在读的过程中有可能导致程序一直挂在那里，永远跳不出while循环。这段代码配合服务端的第一段代码就正好让我们分析服务端永远在那里接收数据，永远跳不出while循环，也就没有之后的服务端返回数据给客户端，客户端也就不可能接收到服务端返回的数据。解决方法如服务端第二段代码所示，在客户端发送数据完毕后，往输出流里面写入结束标记告诉服务端数据已经发送完毕了，同样服务端返回数据完毕后也发一个标记告诉客户端。那么修改后的客户端代码就应该是这个样子：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">      //为了简单起见，所有的异常都直接往外抛  </span><br><span class="line">     String host = &quot;127.0.0.1&quot;;  //要连接的服务端IP地址  </span><br><span class="line">     int port = 8899;   //要连接的服务端对应的监听端口  </span><br><span class="line">     //与服务端建立连接  </span><br><span class="line">     Socket client = new Socket(host, port);  </span><br><span class="line">      //建立连接后就可以往服务端写数据了  </span><br><span class="line">     Writer writer = new OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Server.&quot;);  </span><br><span class="line">      writer.write(&quot;eof&quot;);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      //写完以后进行读操作  </span><br><span class="line">     Reader reader = new InputStreamReader(client.getInputStream());  </span><br><span class="line">      char chars[] = new char[64];  </span><br><span class="line">      int len;  </span><br><span class="line">      StringBuffer sb = new StringBuffer();  </span><br><span class="line">      String temp;  </span><br><span class="line">      int index;  </span><br><span class="line">      while ((len=reader.read(chars)) != -1) &#123;  </span><br><span class="line">         temp = new String(chars, 0, len);  </span><br><span class="line">         if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;  </span><br><span class="line">            sb.append(temp.substring(0, index));  </span><br><span class="line">            break;  </span><br><span class="line">         &#125;  </span><br><span class="line">         sb.append(new String(chars, 0, len));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(&quot;from server: &quot; + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      reader.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们日常使用的比较多的都是这种客户端发送数据给服务端，服务端接收数据后再返回相应的结果给客户端这种形式。只是客户端和服务端之间不再是这种一对一的关系，而是下面要讲到的多个客户端对应同一个服务端的情况。</p></blockquote><h2 id="3-多个客户端连接同一个服务端"><a href="#3-多个客户端连接同一个服务端" class="headerlink" title="3. 多个客户端连接同一个服务端"></a>3. 多个客户端连接同一个服务端</h2><blockquote><p>像前面讲的两个例子都是服务端接收一个客户端的请求之后就结束了，不能再接收其他客户端的请求了，这往往是不能满足我们的要求的。通常我们会这样做：</p></blockquote><h3 id="服务端代码-2"><a href="#服务端代码-2" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常信息都往外抛  </span></span><br><span class="line">     <span class="keyword">int</span> port = <span class="number">8899</span>;  </span><br><span class="line">      <span class="comment">//定义一个ServerSocket监听在端口8899上  </span></span><br><span class="line">     ServerSocket server = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">         <span class="comment">//server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span></span><br><span class="line">       Socket socket = server.accept();  </span><br><span class="line">         <span class="comment">//跟客户端建立好连接之后，我们就可以获取socket的InputStream，并从中读取客户端发过来的信息了。  </span></span><br><span class="line">       Reader reader = <span class="keyword">new</span> InputStreamReader(socket.getInputStream());  </span><br><span class="line">         <span class="keyword">char</span> chars[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];  </span><br><span class="line">         <span class="keyword">int</span> len;  </span><br><span class="line">         StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">         String temp;  </span><br><span class="line">         <span class="keyword">int</span> index;  </span><br><span class="line">         <span class="keyword">while</span> ((len=reader.read(chars)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">            temp = <span class="keyword">new</span> String(chars, <span class="number">0</span>, len);  </span><br><span class="line">            <span class="keyword">if</span> ((index = temp.indexOf(<span class="string">"eof"</span>)) != -<span class="number">1</span>) &#123;<span class="comment">//遇到eof时就结束接收  </span></span><br><span class="line">                sb.append(temp.substring(<span class="number">0</span>, index));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">         System.out.println(<span class="string">"from client: "</span> + sb);  </span><br><span class="line">         <span class="comment">//读完后写一句  </span></span><br><span class="line">       Writer writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">         writer.write(<span class="string">"Hello Client."</span>);  </span><br><span class="line">         writer.flush();  </span><br><span class="line">         writer.close();  </span><br><span class="line">         reader.close();  </span><br><span class="line">         socket.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面代码中我们用了一个死循环，在循环体里面ServerSocket调用其accept方法试图接收来自客户端的连接请求。当没有接收到请求的时候，程序会在这里阻塞直到接收到来自客户端的连接请求，之后会跟当前建立好连接的客户端进行通信，完了后会接着执行循环体再次尝试接收新的连接请求。这样我们的ServerSocket就能接收来自所有客户端的连接请求了，并且与它们进行通信了。这就实现了一个简单的一个服务端与多个客户端进行通信的模式。</p></blockquote><blockquote><p>上述例子中虽然实现了一个服务端跟多个客户端进行通信，但是还存在一个问题。在上述例子中，我们的服务端处理客户端的连接请求是同步进行的，每次接收到来自客户端的连接请求后，都要先跟当前的客户端通信完之后才能再处理下一个连接请求。这在并发比较多的情况下会严重影响程序的性能，为此，我们可以把它改为如下这种异步处理与客户端通信的方式：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Server &#123;  </span><br><span class="line">     </span><br><span class="line">   public static void main(String args[]) throws IOException &#123;  </span><br><span class="line">      //为了简单起见，所有的异常信息都往外抛  </span><br><span class="line">     int port = 8899;  </span><br><span class="line">      //定义一个ServerSocket监听在端口8899上  </span><br><span class="line">     ServerSocket server = new ServerSocket(port);  </span><br><span class="line">      while (true) &#123;  </span><br><span class="line">         //server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span><br><span class="line">         Socket socket = server.accept();  </span><br><span class="line">         //每接收到一个Socket就建立一个新的线程来处理它  </span><br><span class="line">         new Thread(new Task(socket)).start();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   /** </span><br><span class="line">    * 用来处理Socket请求的 </span><br><span class="line">   */  </span><br><span class="line">   static class Task implements Runnable &#123;  </span><br><span class="line">   </span><br><span class="line">      private Socket socket;  </span><br><span class="line">        </span><br><span class="line">      public Task(Socket socket) &#123;  </span><br><span class="line">         this.socket = socket;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      public void run() &#123;  </span><br><span class="line">  </span><br><span class="line">         try &#123;  </span><br><span class="line">  </span><br><span class="line">            handleSocket();  </span><br><span class="line">         &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      /** </span><br><span class="line">       * 跟客户端Socket进行通信 </span><br><span class="line">       * @throws Exception </span><br><span class="line">       */  </span><br><span class="line">      private void handleSocket() throws Exception &#123;  </span><br><span class="line">         Reader reader = new InputStreamReader(socket.getInputStream());  </span><br><span class="line">         char chars[] = new char[64];  </span><br><span class="line">         int len;  </span><br><span class="line">         StringBuilder sb = new StringBuilder();  </span><br><span class="line">         String temp;  </span><br><span class="line">         int index;  </span><br><span class="line">         while ((len=reader.read(chars)) != -1) &#123;  </span><br><span class="line">            temp = new String(chars, 0, len);  </span><br><span class="line">            if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;//遇到eof时就结束接收  </span><br><span class="line">             sb.append(temp.substring(0, index));  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">         System.out.println(&quot;from client: &quot; + sb);  </span><br><span class="line">         //读完后写一句  </span><br><span class="line">       Writer writer = new OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">         writer.write(&quot;Hello Client.&quot;);  </span><br><span class="line">         writer.flush();  </span><br><span class="line">         writer.close();  </span><br><span class="line">         reader.close();  </span><br><span class="line">         socket.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面代码中，每次ServerSocket接收到一个新的Socket连接请求后都会新起一个线程来跟当前Socket进行通信，这样就达到了异步处理与客户端Socket进行通信的情况。</p></blockquote><blockquote><p>在从Socket的InputStream中接收数据时，像上面那样一点点的读就太复杂了，有时候我们就会换成使用BufferedReader来一次读一行，如：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Server &#123;  </span><br><span class="line">   </span><br><span class="line">   public static void main(String args[]) throws IOException &#123;  </span><br><span class="line">      //为了简单起见，所有的异常信息都往外抛  </span><br><span class="line">     int port = 8899;  </span><br><span class="line">      //定义一个ServerSocket监听在端口8899上  </span><br><span class="line">     ServerSocket server = new ServerSocket(port);  </span><br><span class="line">      while (true) &#123;  </span><br><span class="line">         //server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span><br><span class="line">         Socket socket = server.accept();  </span><br><span class="line">         //每接收到一个Socket就建立一个新的线程来处理它  </span><br><span class="line">         new Thread(new Task(socket)).start();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   /** </span><br><span class="line">    * 用来处理Socket请求的 </span><br><span class="line">   */  </span><br><span class="line">   static class Task implements Runnable &#123;  </span><br><span class="line">   </span><br><span class="line">      private Socket socket;  </span><br><span class="line">        </span><br><span class="line">      public Task(Socket socket) &#123;  </span><br><span class="line">         this.socket = socket;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      public void run() &#123;  </span><br><span class="line">         try &#123;  </span><br><span class="line">            handleSocket();  </span><br><span class="line">         &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      /** </span><br><span class="line">       * 跟客户端Socket进行通信 </span><br><span class="line">      * @throws Exception </span><br><span class="line">       */  </span><br><span class="line">      private void handleSocket() throws Exception &#123;  </span><br><span class="line">         BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));  </span><br><span class="line">         StringBuilder sb = new StringBuilder();  </span><br><span class="line">         String temp;  </span><br><span class="line">         int index;  </span><br><span class="line">         while ((temp=br.readLine()) != null) &#123;  </span><br><span class="line">            System.out.println(temp);  </span><br><span class="line">            if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;//遇到eof时就结束接收  </span><br><span class="line">             sb.append(temp.substring(0, index));  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">         System.out.println(&quot;from client: &quot; + sb);  </span><br><span class="line">         //读完后写一句  </span><br><span class="line">       Writer writer = new OutputStreamWriter(socket.getOutputStream());  </span><br><span class="line">         writer.write(&quot;Hello Client.&quot;);  </span><br><span class="line">         writer.write(&quot;eof\n&quot;);  </span><br><span class="line">         writer.flush();  </span><br><span class="line">         writer.close();  </span><br><span class="line">         br.close();  </span><br><span class="line">         socket.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个时候需要注意的是，BufferedReader的readLine方法是一次读一行的，这个方法是阻塞的，直到它读到了一行数据为止程序才会继续往下执行，那么readLine什么时候才会读到一行呢？直到程序遇到了换行符或者是对应流的结束符readLine方法才会认为读到了一行，才会结束其阻塞，让程序继续往下执行。所以我们在使用BufferedReader的readLine读取数据的时候一定要记得在对应的输出流里面一定要写入换行符（流结束之后会自动标记为结束，readLine可以识别），写入换行符之后一定记得如果输出流不是马上关闭的情况下记得flush一下，这样数据才会真正的从缓冲区里面写入。对应上面的代码我们的客户端程序应该这样写：</p></blockquote><h3 id="客户端代码-2"><a href="#客户端代码-2" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">  </span><br><span class="line">   public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">      //为了简单起见，所有的异常都直接往外抛  </span><br><span class="line">     String host = &quot;127.0.0.1&quot;;  //要连接的服务端IP地址  </span><br><span class="line">     int port = 8899;   //要连接的服务端对应的监听端口  </span><br><span class="line">     //与服务端建立连接  </span><br><span class="line">     Socket client = new Socket(host, port);  </span><br><span class="line">      //建立连接后就可以往服务端写数据了  </span><br><span class="line">     Writer writer = new OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(&quot;Hello Server.&quot;);  </span><br><span class="line">      writer.write(&quot;eof\n&quot;);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      //写完以后进行读操作  </span><br><span class="line">     BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));  </span><br><span class="line">      StringBuffer sb = new StringBuffer();  </span><br><span class="line">      String temp;  </span><br><span class="line">      int index;  </span><br><span class="line">      while ((temp=br.readLine()) != null) &#123;  </span><br><span class="line">         if ((index = temp.indexOf(&quot;eof&quot;)) != -1) &#123;  </span><br><span class="line">            sb.append(temp.substring(0, index));  </span><br><span class="line">            break;  </span><br><span class="line">         &#125;  </span><br><span class="line">         sb.append(temp);  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(&quot;from server: &quot; + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      br.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、设置超时时间"><a href="#三、设置超时时间" class="headerlink" title="三、设置超时时间"></a>三、设置超时时间</h1><blockquote><p>假设有这样一种需求，我们的客户端需要通过Socket从服务端获取到XX信息，然后给用户展示在页面上。我们知道Socket在读数据的时候是阻塞式的，如果没有读到数据程序会一直阻塞在那里。在同步请求的时候我们肯定是不能允许这样的情况发生的，这就需要我们在请求达到一定的时间后控制阻塞的中断，让程序得以继续运行。Socket为我们提供了一个setSoTimeout()方法来设置接收数据的超时时间，单位是毫秒。当设置的超时时间大于0，并且超过了这一时间Socket还没有接收到返回的数据的话，Socket就会抛出一个SocketTimeoutException。</p></blockquote><blockquote><p>假设我们需要控制我们的客户端在开始读取数据10秒后还没有读到数据就中断阻塞的话我们可以这样做：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常都直接往外抛  </span></span><br><span class="line">     String host = <span class="string">"127.0.0.1"</span>;  <span class="comment">//要连接的服务端IP地址  </span></span><br><span class="line">     <span class="keyword">int</span> port = <span class="number">8899</span>;   <span class="comment">//要连接的服务端对应的监听端口  </span></span><br><span class="line">     <span class="comment">//与服务端建立连接  </span></span><br><span class="line">     Socket client = <span class="keyword">new</span> Socket(host, port);  </span><br><span class="line">      <span class="comment">//建立连接后就可以往服务端写数据了  </span></span><br><span class="line">     Writer writer = <span class="keyword">new</span> OutputStreamWriter(client.getOutputStream());  </span><br><span class="line">      writer.write(<span class="string">"Hello Server."</span>);  </span><br><span class="line">      writer.write(<span class="string">"eof\n"</span>);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      <span class="comment">//写完以后进行读操作  </span></span><br><span class="line">     BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));  </span><br><span class="line">      <span class="comment">//设置超时间为10秒  </span></span><br><span class="line">     client.setSoTimeout(<span class="number">10</span>*<span class="number">1000</span>);  </span><br><span class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer();  </span><br><span class="line">      String temp;  </span><br><span class="line">      <span class="keyword">int</span> index;  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="keyword">while</span> ((temp=br.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((index = temp.indexOf(<span class="string">"eof"</span>)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                sb.append(temp.substring(<span class="number">0</span>, index));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;  </span><br><span class="line">         System.out.println(<span class="string">"数据读取超时。"</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(<span class="string">"from server: "</span> + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      br.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、接收数据乱码"><a href="#四、接收数据乱码" class="headerlink" title="四、接收数据乱码"></a>四、接收数据乱码</h1><blockquote><p>对于这种服务端或客户端接收中文乱码的情况通常是因为数据发送时使用的编码跟接收时候使用的编码不一致。比如有下面这样一段服务端代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常信息都往外抛  </span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">8899</span>;  </span><br><span class="line">      <span class="comment">//定义一个ServerSocket监听在端口8899上  </span></span><br><span class="line">      ServerSocket server = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">         <span class="comment">//server尝试接收其他Socket的连接请求，server的accept方法是阻塞式的  </span></span><br><span class="line">         Socket socket = server.accept();  </span><br><span class="line">         <span class="comment">//每接收到一个Socket就建立一个新的线程来处理它  </span></span><br><span class="line">         <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(socket)).start();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 用来处理Socket请求的 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> Socket socket;  </span><br><span class="line">        </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Socket socket)</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">this</span>.socket = socket;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">try</span> &#123;  </span><br><span class="line">            handleSocket();  </span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 跟客户端Socket进行通信 </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSocket</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">         BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream(), <span class="string">"GBK"</span>));  </span><br><span class="line">         StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">         String temp;  </span><br><span class="line">         <span class="keyword">int</span> index;  </span><br><span class="line">         <span class="keyword">while</span> ((temp=br.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            System.out.println(temp);  </span><br><span class="line">            <span class="keyword">if</span> ((index = temp.indexOf(<span class="string">"eof"</span>)) != -<span class="number">1</span>) &#123;<span class="comment">//遇到eof时就结束接收  </span></span><br><span class="line">             sb.append(temp.substring(<span class="number">0</span>, index));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">         System.out.println(<span class="string">"客户端: "</span> + sb);  </span><br><span class="line">         <span class="comment">//读完后写一句  </span></span><br><span class="line">       Writer writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream(), <span class="string">"UTF-8"</span>);  </span><br><span class="line">         writer.write(<span class="string">"你好，客户端。"</span>);  </span><br><span class="line">         writer.write(<span class="string">"eof\n"</span>);  </span><br><span class="line">         writer.flush();  </span><br><span class="line">         writer.close();  </span><br><span class="line">         br.close();  </span><br><span class="line">         socket.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里用来测试我就弄的混乱了一点。在上面服务端代码中我们在定义输入流的时候明确定义了使用GBK编码来读取数据，而在定义输出流的时候明确指定了将使用UTF-8编码来发送数据。如果客户端上送数据的时候不以GBK编码来发送的话服务端接收的数据就很有可能会乱码；同样如果客户端接收数据的时候不以服务端发送数据的编码，即UTF-8编码来接收数据的话也极有可能会出现数据乱码的情况。所以，对于上述服务端代码，为使我们的程序能够读取对方发送过来的数据，而不出现乱码情况，我们的客户端应该是这样的：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      <span class="comment">//为了简单起见，所有的异常都直接往外抛  </span></span><br><span class="line">     String host = <span class="string">"127.0.0.1"</span>;  <span class="comment">//要连接的服务端IP地址  </span></span><br><span class="line">     <span class="keyword">int</span> port = <span class="number">8899</span>;   <span class="comment">//要连接的服务端对应的监听端口  </span></span><br><span class="line">     <span class="comment">//与服务端建立连接  </span></span><br><span class="line">     Socket client = <span class="keyword">new</span> Socket(host, port);  </span><br><span class="line">      <span class="comment">//建立连接后就可以往服务端写数据了  </span></span><br><span class="line">     Writer writer = <span class="keyword">new</span> OutputStreamWriter(client.getOutputStream(), <span class="string">"GBK"</span>);  </span><br><span class="line">      writer.write(<span class="string">"你好，服务端。"</span>);  </span><br><span class="line">      writer.write(<span class="string">"eof\n"</span>);  </span><br><span class="line">      writer.flush();  </span><br><span class="line">      <span class="comment">//写完以后进行读操作  </span></span><br><span class="line">     BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream(), <span class="string">"UTF-8"</span>));  </span><br><span class="line">      <span class="comment">//设置超时间为10秒  </span></span><br><span class="line">     client.setSoTimeout(<span class="number">10</span>*<span class="number">1000</span>);  </span><br><span class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer();  </span><br><span class="line">      String temp;  </span><br><span class="line">      <span class="keyword">int</span> index;  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="keyword">while</span> ((temp=br.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((index = temp.indexOf(<span class="string">"eof"</span>)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                sb.append(temp.substring(<span class="number">0</span>, index));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sb.append(temp);  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;  </span><br><span class="line">         System.out.println(<span class="string">"数据读取超时。"</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println(<span class="string">"服务端: "</span> + sb);  </span><br><span class="line">      writer.close();  </span><br><span class="line">      br.close();  </span><br><span class="line">      client.close();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、作者声明"><a href="#五、作者声明" class="headerlink" title="五、作者声明"></a>五、作者声明</h1><p>原文链接：<a href="http://elim.iteye.com/blog/1979837" target="_blank" rel="noopener">http://elim.iteye.com/blog/1979837</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Java-Socket简介&quot;&gt;&lt;a href=&quot;#一、Java-Socket简介&quot; class=&quot;headerlink&quot; title=&quot;一、Java Socket简介&quot;&gt;&lt;/a&gt;一、Java Socket简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;对于Jav
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
