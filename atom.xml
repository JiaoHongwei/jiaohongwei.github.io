<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你只管努力，其他的。 交给天意。</title>
  
  <subtitle>A Madman&#39;s Diary</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiaohongwei.github.io/"/>
  <updated>2019-02-16T15:03:36.309Z</updated>
  <id>https://jiaohongwei.github.io/</id>
  
  <author>
    <name>伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java反射机制笔记</title>
    <link href="https://jiaohongwei.github.io/2018/11/30/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiaohongwei.github.io/2018/11/30/Java反射机制笔记/</id>
    <published>2018-11-30T02:41:08.000Z</published>
    <updated>2019-02-16T15:03:36.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述-amp-应用场景"><a href="#一、概述-amp-应用场景" class="headerlink" title="一、概述&amp;应用场景"></a>一、概述&amp;应用场景</h1><ul><li>Java反射机制是在运行状态中，对于任意一个类（Class）文件，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意一个方法和属性；</li><li>这种动态获取的信息以及动态调用对象的方法的功能成为Java语言的反射机制。</li></ul><blockquote><p>简单说就是动态获取类中信息就是反射机制。</p></blockquote><blockquote><p>可以理解为对类的解剖。</p></blockquote><hr><h1 id="二、细节-amp-Class对象"><a href="#二、细节-amp-Class对象" class="headerlink" title="二、细节&amp;Class对象"></a>二、细节&amp;Class对象</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Class&#123;</span><br><span class="line">    提供获取字节码文件中的内容。</span><br><span class="line">    比如：</span><br><span class="line">    名称，字段，构造函数，一般函数</span><br><span class="line">&#125;</span><br><span class="line">// 该类就可以获取字节码文件中的所有内容，那么反射就是依靠该类完成的。</span><br></pre></td></tr></table></figure><ul><li>想要对一个类文件进行解刨，只需要获取到该类的字节码文件对象即可。</li></ul><blockquote><p>java.lang.Class<t> </t></p></blockquote><ul><li>Class类的类表示正在运行的Java应用程序中的类和接口。 </li><li>枚举是一种类，一个注释是一种界面。 每个数组也属于一个反映为类对象的类，该对象由具有相同元素类型和维数的所有数组共享。 </li><li>原始Java类型（ boolean ， byte ， char ， short ， int ， long ， float和double ），和关键字void也表示为类对象。 </li><li>类没有公共构造函数。 相反， 类对象由Java虚拟机自动构建，因为加载了类，并且通过调用类加载器中的defineClass方法。</li></ul><hr><h1 id="三、获取Class对象的三种方式"><a href="#三、获取Class对象的三种方式" class="headerlink" title="三、获取Class对象的三种方式"></a>三、获取Class对象的三种方式</h1><p>要想对字节码文件进行解刨，必须要有字节码文件对象</p><ol><li>Object类中的getClass方法</li><li>通过对象静态属性 .class来获取对应的Class对象</li><li>只要通过给定类的字符串名称就可以获取该类，更为拓展</li></ol><h2 id="1-object-getClass"><a href="#1-object-getClass" class="headerlink" title="1.  object.getClass()"></a>1.  object.getClass()</h2><blockquote><p>创建Person类</p></blockquote><p>必须要明确具体的类，并且要创建对象，麻烦。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hw.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/11/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"... show run ..."</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"privateMethod run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paramMethod</span><span class="params">(String str, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"paramMethod run..."</span> + str + <span class="string">": "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"staticMethod run ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"person run ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">"person param run ... name="</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试用例</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取Class对象的三种方式</span><br><span class="line"> * 1.Object类中的getClass()方法，必须要明确具体的类，并且要创建对象，麻烦。</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getClassObject_1() &#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    Class clazz = person.getClass();</span><br><span class="line"></span><br><span class="line">    Person person1 = new Person();</span><br><span class="line">    Class clazz1 = person1.getClass();</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz == clazz1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130000917879.png" alt></p><h2 id="2-Object-class"><a href="#2-Object-class" class="headerlink" title="2. Object.class"></a>2. Object.class</h2><p>相对简单，但是还是需要先明确类中的静态成员。不够拓展。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过对象静态属性 .class来获取对应的Class对象</span><br><span class="line"> */</span><br><span class="line">public void getClassObject_2() &#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Class-forName-className"><a href="#3-Class-forName-className" class="headerlink" title="3. Class.forName(className)"></a>3. Class.forName(className)</h2><p>这种方法只要有名称即可，更为方便，拓展性更强。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 方式三：只要通过给定类的字符串名称就可以获取该类，更为拓展，forName</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getClassObject_3() throws ClassNotFoundException &#123;</span><br><span class="line">    String className = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    Class clazz = Class.forName(className);</span><br><span class="line">    System.out.println(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130002216418.png" alt></p><hr><h1 id="四、获取Class中的构造函数"><a href="#四、获取Class中的构造函数" class="headerlink" title="四、获取Class中的构造函数"></a>四、获取Class中的构造函数</h1><h2 id="1-new创建对象"><a href="#1-new创建对象" class="headerlink" title="1. new创建对象"></a>1. new创建对象</h2><ul><li>早期创建对象,先根据被new的类的名称找寻该类的字节码文件，并加载进内存，并创建该字节码文件对象，并接着创建该接文件的对应的Person对象</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.hw.bean.Person p = new com.hw.bean.Person();</span><br></pre></td></tr></table></figure><h2 id="2-反射创建对象"><a href="#2-反射创建对象" class="headerlink" title="2. 反射创建对象"></a>2. 反射创建对象</h2><ul><li>找寻该名称类文件，并加载进内存，调用newInstance() 创建由此 类对象表示的类的新实例。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createNewObject_1() throws Exception &#123;</span><br><span class="line">    // 早期创建对象,先根据被new的类的名称找寻该类的字节码文件，并加载进内存，</span><br><span class="line">    // 并创建该字节码文件对象，并接着创建该接文件的对应的Person对象</span><br><span class="line">    com.hw.bean.Person p = new com.hw.bean.Person();</span><br><span class="line"></span><br><span class="line">    // 现在</span><br><span class="line">    String name = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    // 找寻该名称类文件，并加载进内存，并产生Class对象</span><br><span class="line">    Class clazz = Class.forName(name);</span><br><span class="line">    // 通过空参构造器获取实例</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/30/Java反射机制笔记/20181130004030863.png" alt></p><ul><li>当获取指定名称对应类中的所体现的对象时，而该对象初始化不是用空参数构造该怎么办呢？</li><li>既然是通过指定的构造函数，进行对象的初始化，所以应该先获取到构造函数。</li></ul><h2 id="3-获取Class中的构造函数"><a href="#3-获取Class中的构造函数" class="headerlink" title="3. 获取Class中的构造函数"></a>3. 获取Class中的构造函数</h2><blockquote><p>getConstructor(类&lt;?&gt;… parameterTypes) </p></blockquote><ul><li>返回一个 Constructor对象，该对象反映 Constructor对象表示的类的指定的公共 类函数。 </li><li>parameterTypes参数是以声明顺序标识构造函数的形式参数类型的类对象的数组。</li><li>如果此类对象表示在非静态上下文中声明的内部类，则形式参数类型将显式包围实例作为第一个参数。</li><li>反映的构造是这样表示的类的公共构造类对象，其形式参数类型匹配那些由指定的parameterTypes 。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createNewObject_2() throws Exception &#123;</span><br><span class="line">    String name = &quot;com.hw.bean.Person&quot;;</span><br><span class="line">    Class clazz = Class.forName(name);</span><br><span class="line">    // 获取指定方法参数的构造对象</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">    // 通过该构造器对象的newInstance()方法进行对象的初始化</span><br><span class="line">    Object obj = constructor.newInstance(&quot;小明&quot;, 22);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><p><img src="/2018/11/30/Java反射机制笔记/20181130005233982.png" alt></p><hr><h1 id="五、获取Class中的字段"><a href="#五、获取Class中的字段" class="headerlink" title="五、获取Class中的字段"></a>五、获取Class中的字段</h1><h2 id="1-getField-String-name"><a href="#1-getField-String-name" class="headerlink" title="1. getField(String name)"></a>1. getField(String name)</h2><ul><li>返回一个 Field对象，它反映此表示的类或接口的指定公共成员字段 类对象。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取字节码文件的字段</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Field name = clazz.getField(&quot;name&quot;);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130005820538.png" alt></p><p>报错，原因是字段是私有的。</p><p>要反映的字段由以下算法确定。 让C成为由该对象表示的类或接口： </p><ul><li>如果C声明一个具有指定名称的公共字段，那就是要反映的字段。 </li><li>如果在上述步骤1中没有找到字段，则将该算法递归地应用于C的每个直接超级接口。直接超级接口按照它们被声明的顺序被搜索。 </li><li>如果在上面的步骤1和2中没有找到字段，并且C具有超类S，则该算法在S上递归地调用。如果C没有超类，则抛出NoSuchFieldException 。 </li></ul><h2 id="2-getDeclaredField-String-name"><a href="#2-getDeclaredField-String-name" class="headerlink" title="2. getDeclaredField(String name)"></a>2. getDeclaredField(String name)</h2><ul><li>只获取本类 但包含私有</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line"></span><br><span class="line">    Field field = // clazz.getField(&quot;name&quot;);</span><br><span class="line">            clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    Object age = field.get(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130010456310.png" alt></p><p>还是报错，不能访问私有的</p><h2 id="3-AccessibleObject-属性"><a href="#3-AccessibleObject-属性" class="headerlink" title="3. AccessibleObject 属性"></a>3. AccessibleObject 属性</h2><ul><li>AccessibleObject类是Field，Method和Constructor对象的基类。 它提供了将反射对象标记为在使用它时抑制默认Java语言访问控制检查的功能。</li><li>当使用Fields，Methods或Constructors来设置或获取字段，调用方法，或创建和初始化新的类实例时，执行访问检查（对于public，默认（包）访问，受保护和私有成员）。</li></ul><blockquote><p>setAccessible(boolean flag)  暴力访问</p></blockquote><ul><li>将此对象的 accessible标志设置为指示的布尔值。 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getFieldDemo() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line"></span><br><span class="line">    Field field = // clazz.getField(&quot;name&quot;);</span><br><span class="line">            clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">    // 对私有字段的访问取消权限检查。暴力访问</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    // 对字段赋值</span><br><span class="line">    field.set(instance,&quot;张四&quot;);</span><br><span class="line">    Object name = field.get(instance);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130011330038.png" alt></p><hr><h1 id="六、获取Class中的方法"><a href="#六、获取Class中的方法" class="headerlink" title="六、获取Class中的方法"></a>六、获取Class中的方法</h1><h2 id="1-getMethods"><a href="#1-getMethods" class="headerlink" title="1. getMethods()"></a>1. getMethods()</h2><ul><li><p>获取的都是共有的方法（包括父类）</p></li><li><p>返回包含一个数组 方法对象反射由此表示的类或接口的所有公共方法 类对象，包括那些由类或接口和那些从超类和超接口继承的声明。</p></li><li>如果此类对象表示具有多个具有相同名称和参数类型但具有不同返回类型的公共方法的类型，则返回的数组对于每个此类方法都有一个方法对象。 </li><li>如果此类对象表示与类初始化方法的类型<clinit> ，则返回的阵列不具有相应的方法对象。 </clinit></li><li>如果此类对象表示一个数组类型，则返回的阵列具有方法对于每个由阵列类型从继承的公共方法对象Object 。 它不包含方法对象clone() 。 </li><li>如果此类对象表示一个接口，那么返回的数组不包含任何隐含声明的方法，从Object 。因此，如果在此接口或其任何超级接口中没有显式声明方法，则返回的数组的长度为0.（注意，表示类的类对象始终具有从Object公共方法）。 </li><li>如果此类对象表示原始类型或空值，则返回的数组的长度为0。 </li><li>由此类对象表示的类或接口的超级接口中声明的静态方法不被视为类或接口的成员。 </li><li>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取指定Class中的公共函数</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void getMethodDemo() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130012039348.png" alt></p><h2 id="2-getDeclaredMethods"><a href="#2-getDeclaredMethods" class="headerlink" title="2. getDeclaredMethods()"></a>2. getDeclaredMethods()</h2><ul><li>获取本类中的所有的方法（包含私有的）</li><li>返回包含一个数组方法对象反射的类或接口的所有声明的方法，通过此表示类对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。 </li><li>如果此类对象表示具有多个具有相同名称和参数类型但具有不同返回类型的声明方法的类型，则返回的数组对于每个此类方法都有一个方法对象。 </li><li>如果此类对象表示具有类初始化方法的类型<clinit> ，则返回的阵列不具有相应的方法对象。 </clinit></li><li>如果此类对象表示没有声明方法的类或接口，则返回的数组的长度为0。 </li><li>如果这个类对象表示一个数组类型，一个基本类型，或者是void，则返回的数组的长度为0。 </li><li>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_2() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130012438582.png" alt></p><h2 id="3-getMethod-String-name-类-lt-gt-…-parameterTypes"><a href="#3-getMethod-String-name-类-lt-gt-…-parameterTypes" class="headerlink" title="3. getMethod(String name, 类&lt;?&gt;… parameterTypes)"></a>3. getMethod(String name, 类&lt;?&gt;… parameterTypes)</h2><ul><li>获取单个方法</li><li>返回一个方法对象，它反映此表示的类或接口的指定公共成员方法类对象。 </li><li>name参数是一个String它指定了所需方法的简单名称。 </li><li>parameterTypes参数是以声明顺序标识方法的形式参数类型的类对象的数组。 </li><li>如果parameterTypes是null ，它被视为一个空数组。 </li></ul><blockquote><p>方法无参 方式一：使用无参构造器（默认） method.invoke(o, null)</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_3() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    // 获取空参的一般方法</span><br><span class="line">    Method method = clazz.getMethod(&quot;show&quot;, null);</span><br><span class="line">    Object o = clazz.newInstance();</span><br><span class="line">    method.invoke(o, null);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130013410485.png" alt></p><blockquote><p>方法无参 方式二：使用有参构造器  method.invoke(o, null)</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_4() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    // 获取空参的一般方法</span><br><span class="line">    Method method = clazz.getMethod(&quot;show&quot;, null);</span><br><span class="line">    // 获取带参构造器</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    Object o = constructor.newInstance(&quot;小明&quot;, 12);</span><br><span class="line">    method.invoke(o, null);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130013645030.png" alt></p><blockquote><p>方法有参 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodDemo_5() throws Exception &#123;</span><br><span class="line">    Class clazz = Class.forName(&quot;com.hw.bean.Person&quot;);</span><br><span class="line">    Method method = clazz.getMethod(&quot;paramMethod&quot;, String.class, int.class);</span><br><span class="line">    // 获取带参构造器</span><br><span class="line">    Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line">    Object o = constructor.newInstance(&quot;小明&quot;, 12);</span><br><span class="line">    method.invoke(o, &quot;张三&quot;, 18);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="/2018/11/30/Java反射机制笔记/20181130014202027.png" alt></p><hr><h1 id="七、源码"><a href="#七、源码" class="headerlink" title="七、源码"></a>七、源码</h1><p>本章节源码: <a href="https://github.com/JiaoHongwei/Reflection" target="_blank" rel="noopener">ReflectDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述-amp-应用场景&quot;&gt;&lt;a href=&quot;#一、概述-amp-应用场景&quot; class=&quot;headerlink&quot; title=&quot;一、概述&amp;amp;应用场景&quot;&gt;&lt;/a&gt;一、概述&amp;amp;应用场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java反射机制是在运行状态中，对于任意
      
    
    </summary>
    
    
      <category term="Java高级编程" scheme="https://jiaohongwei.github.io/tags/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
      <category term="反射" scheme="https://jiaohongwei.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux cp/rm/mv强制覆盖</title>
    <link href="https://jiaohongwei.github.io/2017/08/18/Linux-cp-rm-mv%E5%BC%BA%E5%88%B6%E8%A6%86%E7%9B%96/"/>
    <id>https://jiaohongwei.github.io/2017/08/18/Linux-cp-rm-mv强制覆盖/</id>
    <published>2017-08-18T10:34:00.000Z</published>
    <updated>2019-02-17T03:44:45.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述Linux下的cp/rm/mv强制覆盖以及在Java中的调用（博客园文章迁移）</p></blockquote><h1 id="一、Linux下的cp-rm-mv强制覆盖"><a href="#一、Linux下的cp-rm-mv强制覆盖" class="headerlink" title="一、Linux下的cp/rm/mv强制覆盖"></a>一、Linux下的cp/rm/mv强制覆盖</h1><h2 id="1-反斜杠（-）临时取消别名"><a href="#1-反斜杠（-）临时取消别名" class="headerlink" title="1. 反斜杠（\）临时取消别名"></a>1. 反斜杠（\）临时取消别名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]# \cp filename new/filename   </span><br><span class="line">[root@fz ~]#</span><br></pre></td></tr></table></figure><h2 id="2-unalias-取消别名"><a href="#2-unalias-取消别名" class="headerlink" title="2. unalias 取消别名"></a>2. unalias 取消别名</h2><blockquote><p>注意：这只是临时取消cp的别名，不是永久的</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# unalias cp   </span><br><span class="line">[root@localhost ~]# cp filename new/filename   </span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h2 id="3-修改默认配置文件"><a href="#3-修改默认配置文件" class="headerlink" title="3. 修改默认配置文件"></a>3. 修改默认配置文件</h2><blockquote><p>输入alias命令，看到系统内部使用的是cp、mv、rm -i 所以怎么输入都是提示覆盖。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]#</span><br><span class="line">[root@fz ~]# alias</span><br><span class="line">alias cdd=&apos;cd /home/data/android/&apos;</span><br><span class="line">alias cp=&apos;cp -i&apos;</span><br><span class="line">alias l=&apos;ls -la&apos;</span><br><span class="line">alias l.=&apos;ls -d .* --color=auto&apos;</span><br><span class="line">alias ll=&apos;ls -l --color=auto&apos;</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br><span class="line">alias mv=&apos;mv -i&apos;</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias tf=&apos;tail -f &apos;</span><br><span class="line">alias vc=&apos;vim ~/.bash_profile&apos;</span><br><span class="line">alias vs=&apos;source ~/.bash_profile&apos;</span><br><span class="line">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br></pre></td></tr></table></figure><blockquote><p>修改 ~/.bashrc ，在 “alias cp=’cp -i’ ”前添加<code>#</code>号注释后即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz test]# vi ~/.bashrc </span><br><span class="line"># .bashrc</span><br><span class="line"></span><br><span class="line"># User specific aliases and functions</span><br><span class="line"></span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">#alias cp=&apos;cp -i&apos;</span><br><span class="line">alias mv=&apos;mv -i&apos;</span><br><span class="line"></span><br><span class="line"># Source global definitions</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>重启或者执行 source ~/.bashrc 让命令生效</p></blockquote><h2 id="4-yes指令-管道-自动输入yes"><a href="#4-yes指令-管道-自动输入yes" class="headerlink" title="4. yes指令+管道 自动输入yes"></a>4. yes指令+管道 自动输入yes</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@fz ~]# yes | cp filename new/filename   </span><br><span class="line">cp: overwrite `new/filename&apos;? [root@localhost ~]#</span><br></pre></td></tr></table></figure><hr><h1 id="二、Java后台调用Linux命令实现"><a href="#二、Java后台调用Linux命令实现" class="headerlink" title="二、Java后台调用Linux命令实现"></a>二、Java后台调用Linux命令实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void copyIcon() throws IOException, InterruptedException &#123;</span><br><span class="line">      Runtime r = Runtime.getRuntime();</span><br><span class="line">      String cmd_copy = &quot;\\cp -rf temp/AppIcon/*  icon/&quot;;    //copy并覆盖</span><br><span class="line">      String[] cmds = new String[]&#123;&quot;sh&quot;,&quot;-c&quot;,cmd_copy&#125;;</span><br><span class="line">      Process p = r.exec(cmds);</span><br><span class="line">      int result = p.waitFor();</span><br><span class="line">      if (result == 0)&#123;   //表示正常结束</span><br><span class="line">          logger.error(&quot;【copy appIcon 成功】&quot;);</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">          logger.error(&quot;【copy appIcon 失败】&quot;+cmd_copy);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述Linux下的cp/rm/mv强制覆盖以及在Java中的调用（博客园文章迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Linux下的cp-rm-mv强制覆盖&quot;&gt;&lt;a href=&quot;#一、Linux下的cp-rm-mv强制覆盖
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://jiaohongwei.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Oracle CLOB 笔记</title>
    <link href="https://jiaohongwei.github.io/2017/08/18/Oracle-CLOB-%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiaohongwei.github.io/2017/08/18/Oracle-CLOB-笔记/</id>
    <published>2017-08-18T06:36:19.000Z</published>
    <updated>2019-02-17T03:29:34.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记述Oracle的CLOB大数据字段类型（博客园文章迁移）</p></blockquote><h1 id="一、Oracle中的varchar2类型"><a href="#一、Oracle中的varchar2类型" class="headerlink" title="一、Oracle中的varchar2类型"></a>一、Oracle中的varchar2类型</h1><ul><li>我们在Oracle数据库存储的字符数据一般是用VARCHAR2。VARCHAR2既分PL/SQL Data Types中的变量类型，也分Oracle Database中的字段类型，不同场景的最大长度不同。</li><li>在Oracle Database中，VARCHAR2 字段类型，最大值为4000；PL/SQL中 VARCHAR2 变量类型，最大字节长度为32767。</li><li>当 VARCHAR2 容纳不下我们需要存储的信息时，就出来的Oracle的大数据类型LOB( Large Object，大型对象)。</li></ul><hr><h1 id="二、Oarcle中的LOB类型"><a href="#二、Oarcle中的LOB类型" class="headerlink" title="二、Oarcle中的LOB类型"></a>二、Oarcle中的LOB类型</h1><ul><li>在Oracle中，LOB（Large Object，大型对象）类型的字段现在用得越来越多了。因为这种类型的字段，容量大（最多能容纳4GB的数据），且一个表中可以有多个这种类型的字段，很灵活，适用于数据量非常大的业务领域（如图象、档案等）。</li><li>LOB类型分为BLOB和CLOB两种：BLOB即二进制大型对象（Binary Large Object），适用于存贮非文本的字节流数据（如程序、图象、影音等）。</li><li>而CLOB，即字符型大型对象（Character Large Object），则与字符集相关，适于存贮文本型的数据（如历史档案、大部头著作等）。</li></ul><hr><h1 id="三、DB中使用CLOB类型字段"><a href="#三、DB中使用CLOB类型字段" class="headerlink" title="三、DB中使用CLOB类型字段"></a>三、DB中使用CLOB类型字段</h1><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h2><blockquote><p>（使用sql或者直接在PL/SQL客户端创建），字段类型CLOB</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create table</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TEMP</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">name</span>      VARCHAR2(<span class="number">200</span>),</span><br><span class="line">  age       <span class="built_in">NUMBER</span>,</span><br><span class="line">  temp_clob <span class="keyword">CLOB</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">tablespace</span> INSIGHTDATA3_TS</span><br><span class="line">  pctfree <span class="number">10</span></span><br><span class="line">  <span class="keyword">initrans</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">maxtrans</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">storage</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">initial</span> <span class="number">160</span>K</span><br><span class="line">    <span class="keyword">next</span> <span class="number">1</span>M</span><br><span class="line">    <span class="keyword">minextents</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">maxextents</span> <span class="keyword">unlimited</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h2 id="2-增删改查"><a href="#2-增删改查" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h2><p>先看一下使用普通方式的sql操作CLOB类型：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.name, t.temp_clob <span class="keyword">FROM</span> temp t; <span class="comment">--普通查询 INSERT INTO temp t VALUES ('Grand.Jon', 22, '加入博客园的第一天');</span></span><br></pre></td></tr></table></figure><p>查询因为不是varchar2类型，所以普通查询看不到CLOB类型的字段内容，结果如下</p><p><img src="/2017/08/18/Oracle-CLOB-笔记/20170818131552506.png" alt></p><p>而普通插入操作也会因为Oracle的隐式转换，默认把字符串转换成varchar2类型，一旦字符串内容超过varchar2的最大限度就会报会报ora-01704（字符串太长）错误。</p><p>正确操作：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用PL/SQL语法，采取绑定变量的方式解决，而不是直接拼接SQL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">       V_LANG <span class="keyword">CLOB</span> := <span class="string">'待插入的海量字符串'</span>;</span><br><span class="line">       </span><br><span class="line">       V_UPDATE CLOB := '更新的海量字符串';</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp t <span class="keyword">VALUES</span> (<span class="string">'Grand.Jon'</span>, <span class="number">22</span>, V_LANG);        <span class="comment">--增加</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> temp t <span class="keyword">SET</span> t.temp_clob = V_UPDATE <span class="keyword">WHERE</span> <span class="keyword">rownum</span> = <span class="number">1</span>;  <span class="comment">--修改</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> t.NAME, dbms_lob.substr(t.temp_clob) <span class="keyword">FROM</span> TEMP t;    <span class="comment">--查询　　将CLOB转成字符类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">DELETE</span> temp t <span class="keyword">WHERE</span> <span class="keyword">rownum</span> = <span class="number">1</span>;                             <span class="comment">--按列删除　　</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><blockquote><p>对CLOB的操作我们在存储过程中基本上使用 dbms_lob 中 substr , append , write 等方法。</p></blockquote><p>dbms_lob 方法总结</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">dbms_lob.createtemporary(V_SQL,true);     <span class="comment">--创建一个临时clob，用来存储拼接的sql</span></span><br><span class="line">dbms_lob.write(v_SQL,'写入信息');          <span class="comment">--写入操作</span></span><br><span class="line">dbms_lob.append(v_SQL,',');               <span class="comment">--拼接clob</span></span><br><span class="line">dbms_lob.substr(v_SQL);                   <span class="comment">--截取clob，不传参数就是全部读取</span></span><br><span class="line">dbms_lob.freetemporary(v_SQL);            <span class="comment">--释放clob</span></span><br></pre></td></tr></table></figure><p>查询结果如下：</p><p><img src="/2017/08/18/Oracle-CLOB-笔记/20170818133801834.png" alt></p><hr><h1 id="四、在存储过程中使用CLOB类型实例"><a href="#四、在存储过程中使用CLOB类型实例" class="headerlink" title="四、在存储过程中使用CLOB类型实例"></a>四、在存储过程中使用CLOB类型实例</h1><blockquote><p>需求：以开发的存储过程为例，需要循环遍历时间范围拼接sql，将时间日期按列反转（pivot），如果时间太长（1年以上）sql语句（varchar2）就会超出范围报错，这时候就需要使用CLOB来存储拼接的sql。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PROCEDURE P_AND_CPT_RATIOOTH_APP_BAK2_N(</span><br><span class="line">            V_APPIDS IN VARCHAR2,</span><br><span class="line">            V_TYPE IN VARCHAR2,</span><br><span class="line">            V_CHANNEL IN VARCHAR2,</span><br><span class="line">            V_TABLE IN VARCHAR2,</span><br><span class="line">            V_START IN VARCHAR2,</span><br><span class="line">            V_END IN VARCHAR2,</span><br><span class="line">            RESULT OUT mycursor</span><br><span class="line">) IS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">V_SQL CLOB;</span><br><span class="line">V_SQLWHERE VARCHAR2(32767) default  '';</span><br><span class="line">V_SQLWHERE_CHANNEL VARCHAR2(32767) default '';</span><br><span class="line">V_SQL_DATES  CLOB;</span><br><span class="line">V_Sdate  DATE;</span><br><span class="line">V_Edate  DATE;</span><br><span class="line">V_TABLE_DATE VARCHAR2(50);</span><br><span class="line">V_TABLE_TYPE VARCHAR2(50);</span><br><span class="line">V_START_DATE VARCHAR2(50);</span><br><span class="line">V_END_DATE   VARCHAR2(50);</span><br><span class="line"></span><br><span class="line">V_DAY VARCHAR2(50);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">select</span> column_name <span class="keyword">into</span> V_TABLE_DATE <span class="keyword">from</span> user_tab_columns <span class="keyword">where</span> table_name=<span class="string">''</span>||V_TABLE||<span class="string">''</span> <span class="keyword">and</span> column_id=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">select</span> column_name <span class="keyword">into</span> V_TABLE_TYPE <span class="keyword">from</span> user_tab_columns <span class="keyword">where</span> table_name=<span class="string">''</span>||V_TABLE||<span class="string">''</span> <span class="keyword">and</span> column_id=<span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">    dbms_lob.createtemporary(V_SQL,true);<span class="comment">--创建一个临时lob</span></span><br><span class="line">    dbms_lob.createtemporary(V_SQL_DATES,true);<span class="comment">--创建一个临时lob</span></span><br><span class="line">    </span><br><span class="line">    IF V_APPIDS is NOT NULL THEN</span><br><span class="line">       V_SQLWHERE := 'AND t.appid in ('||V_APPIDS||')';</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">    IF V_CHANNEL IS NOT NULL THEN</span><br><span class="line">       V_SQLWHERE_CHANNEL := 'AND t.channel = '''||V_CHANNEL||'''';</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    IF V_TABLE_DATE = 'MON' THEN</span><br><span class="line">       V_START_DATE := SUBSTR(V_START,0,6);</span><br><span class="line">       V_END_DATE :=  SUBSTR(V_END,0,6);</span><br><span class="line">       v_sdate := to_date(V_START_DATE, 'yyyymm');</span><br><span class="line">       v_edate := to_date(V_END_DATE, 'yyyymm');</span><br><span class="line">       </span><br><span class="line">        WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">              dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymm'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">        IF v_sdate != v_edate THEN</span><br><span class="line">              dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">        v_sdate := add_months(v_sdate,1);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    ELSE  <span class="comment">--周和日 类型 都是 DAY</span></span><br><span class="line">      </span><br><span class="line">       v_sdate := to_date(V_START, 'yyyymmdd');</span><br><span class="line">       v_edate := to_date(V_END, 'yyyymmdd');</span><br><span class="line">       V_END_DATE :=  V_END;</span><br><span class="line">       </span><br><span class="line">       IF SUBSTR(V_TYPE,0,1)='d' THEN</span><br><span class="line">            V_START_DATE := to_char(v_sdate, 'yyyymmdd');</span><br><span class="line"></span><br><span class="line">            WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">                  dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymmdd'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">            IF v_sdate != v_edate THEN</span><br><span class="line">                  dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">            v_sdate := v_sdate+1;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">       </span><br><span class="line">       ELSIF SUBSTR(V_TYPE,0,1)='w' THEN</span><br><span class="line"></span><br><span class="line">           <span class="keyword">select</span> to_char(V_Sdate,<span class="string">'d'</span>) <span class="keyword">INTO</span> V_DAY <span class="keyword">from</span> dual;</span><br><span class="line">            IF V_DAY!=2 THEN</span><br><span class="line">             V_Sdate:=V_Sdate-7;</span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">          V_START_DATE := to_char(v_sdate, 'yyyymmdd');</span><br><span class="line"></span><br><span class="line">          WHILE (v_sdate &lt;= v_edate) LOOP</span><br><span class="line">               <span class="keyword">select</span> to_char(V_Sdate,<span class="string">'d'</span>) <span class="keyword">INTO</span> V_DAY <span class="keyword">from</span> dual;</span><br><span class="line">              IF V_DAY=2 THEN</span><br><span class="line">                 dbms_lob.append(v_SQL_DATES,to_char(v_sdate, 'yyyymmdd'));<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">                 IF V_Edate-v_sdate &gt;7 THEN</span><br><span class="line">                   dbms_lob.append(v_SQL_DATES,',');<span class="comment">--把临时字符串付给v_str</span></span><br><span class="line">                 <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">            v_sdate := v_sdate+1;</span><br><span class="line">           <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    dbms_lob.append(v_sql,'<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>( <span class="keyword">SELECT</span> *</span><br><span class="line">            <span class="keyword">FROM</span> <span class="string">'||V_TABLE||'</span> t</span><br><span class="line">           <span class="keyword">WHERE</span> </span><br><span class="line">                 t.<span class="string">'||V_TABLE_TYPE||'</span> = <span class="string">'''||V_TYPE||'''</span></span><br><span class="line">             <span class="keyword">AND</span> t.<span class="string">'||V_TABLE_DATE||'</span> &gt;= <span class="string">'''||V_START_DATE||'''</span></span><br><span class="line">             <span class="keyword">AND</span> t.<span class="string">'||V_TABLE_DATE||'</span> &lt;= <span class="string">'''||V_END_DATE||'''</span></span><br><span class="line">             <span class="string">'||V_SQLWHERE||'</span>         </span><br><span class="line">             <span class="string">'||V_SQLWHERE_CHANNEL||'</span> ) t1</span><br><span class="line"> </span><br><span class="line">           <span class="keyword">pivot</span>(<span class="keyword">sum</span>(MARKETSHARE)</span><br><span class="line">             <span class="keyword">for</span> <span class="string">'||V_TABLE_DATE||'</span> <span class="keyword">in</span>(<span class="string">');</span></span><br><span class="line"><span class="string">             </span></span><br><span class="line"><span class="string">    dbms_lob.append(v_sql,v_SQL_DATES);</span></span><br><span class="line"><span class="string">    dbms_lob.append(v_sql,'</span>))<span class="string">');</span></span><br><span class="line"><span class="string">    dbms_output.put_line(v_sql);      </span></span><br><span class="line"><span class="string">    OPEN result FOR v_sql;   </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">       dbms_lob.freetemporary(v_sql);--释放lob</span></span><br><span class="line"><span class="string">       dbms_lob.freetemporary(v_SQL_DATES);--释放lob</span></span><br><span class="line"><span class="string">       --dbms_output.put_line(V_SQLDATE);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      -- dbms_output.put_line(v_SQL_DATES);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--记录操作日志及错误日志</span></span><br><span class="line"><span class="string">END;</span></span><br></pre></td></tr></table></figure><hr><h1 id="五、使用Java开发操作CLOB字段"><a href="#五、使用Java开发操作CLOB字段" class="headerlink" title="五、使用Java开发操作CLOB字段"></a>五、使用Java开发操作CLOB字段</h1><h2 id="1-原生JDBC处理CLOB类型"><a href="#1-原生JDBC处理CLOB类型" class="headerlink" title="1. 原生JDBC处理CLOB类型"></a>1. 原生JDBC处理CLOB类型</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><blockquote><p>增加，一般会插入一个空的clob到数据库对应的字段,然后锁定该列，用Write将待插入字符串写入进去。</p></blockquote><ul><li>重点：这两步操作要放在同一个事务里面。具体增加的方法如下:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean save(Article article)&#123;</span><br><span class="line">    boolean result = true;</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;insert into temp values(?,?,empty_clob())&quot;;</span><br><span class="line">    //锁住该列，防止并发写入时候该字段同时被多次写入造成错误</span><br><span class="line">    String sqlClob = &quot;select temp_clob from temp t where t.name=? for update&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    Writer writer = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        conn.setAutoCommit(false);//设置不自动提交，开启事务</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setString(1,article.getName());</span><br><span class="line">        pst.setString(2,article.getAge());</span><br><span class="line">        pst.executeUpdate();</span><br><span class="line"></span><br><span class="line">        pst= conn.prepareStatement(sqlClob);</span><br><span class="line">        pst.setInt(1, article.getId());</span><br><span class="line"></span><br><span class="line">        rs = pst.executeQuery();</span><br><span class="line">        CLOB clob = null;</span><br><span class="line">        if(rs.next())&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clob = (CLOB) rs.getClob(1);</span><br><span class="line">                writer = clob.getCharacterOutputStream(); //拿到clob的字符输入流</span><br><span class="line">                writer.write(article.getContent());</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        result = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn.rollback();//当commit或者rollback后会自动释放该列的锁定</span><br><span class="line">        &#125; catch (SQLException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        conn.setAutoCommit(true);//还原</span><br><span class="line">        ConnectionUntils.close(rs, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><blockquote><p>update操作，update时候主要利用PreparedStatement的setClob方法:</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean update(String name,String content)&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;update temp set temp_clob=? where name=?&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    try &#123;</span><br><span class="line">        CLOB clob   = oracle.sql.CLOB.createTemporary(conn, false,oracle.sql.CLOB.DURATION_SESSION);</span><br><span class="line">        clob.setString(1L, content);</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setClob(1, clob);</span><br><span class="line">        pst.setString(2,name);</span><br><span class="line">        result = pst.executeUpdate();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        ConnectionUntils.close(null, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    if(result==0)</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><blockquote><p>查询就主要是从结果集ResultSet中定位到对应的字段后，往外读：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Article select(String name)&#123;</span><br><span class="line">    Article article = new Article();</span><br><span class="line">    Connection conn = ConnectionUntils.getInstance();</span><br><span class="line">    String sql = &quot;select name,age,temp_clog from temp where name = ?&quot;;</span><br><span class="line">    PreparedStatement pst =null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        pst = conn.prepareStatement(sql);</span><br><span class="line">        pst.setInt(1,id);</span><br><span class="line">        rs = pst.executeQuery();</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        if(rs.next())&#123;</span><br><span class="line">            Clob clob = rs.getClob(&quot;temp_clog&quot;);</span><br><span class="line">            Reader rd = clob.getCharacterStream();</span><br><span class="line">            char [] str = new char[12];</span><br><span class="line">            while(rd.read(str) != -1) &#123;</span><br><span class="line">                builder.append(new String(str));</span><br><span class="line">            &#125;</span><br><span class="line">            article.setContent(builder.toString());</span><br><span class="line">            article.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">            article.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        ConnectionUntils.close(rs, pst, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    return article;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Hibernate、Mybatis框架操作"><a href="#2-Hibernate、Mybatis框架操作" class="headerlink" title="2. Hibernate、Mybatis框架操作"></a>2. Hibernate、Mybatis框架操作</h2><blockquote><p>因为框架都封装集成好了，所以我们使用的时候直接配置变量的类型为CLOB就可以。</p></blockquote><p>譬如：Mybatis</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"temp_clob"</span> <span class="attr">property</span>=<span class="string">"content"</span> <span class="attr">jdbcType</span>=<span class="string">"Clob"</span>  <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.ClobTypeHandler"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>貌似Hibernate5内部做了对应的处理，可以直接当string类型一样处理即可。</p><hr><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><blockquote><p>虽然CLOB能解决VARCHAR2字符大小的限制，但是我们的DBA们都不建议用这些来处理，可能效率问题吧，大的文件应该放在服务器上，然后Database中存响应地址即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记述Oracle的CLOB大数据字段类型（博客园文章迁移）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Oracle中的varchar2类型&quot;&gt;&lt;a href=&quot;#一、Oracle中的varchar2类型&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://jiaohongwei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Oracle" scheme="https://jiaohongwei.github.io/tags/Oracle/"/>
    
  </entry>
  
</feed>
